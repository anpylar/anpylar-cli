
;(function() {
    var vfspath = "anpylar.vfs.js"
    var $vfs = {"anpylar.observable": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .observable_base import (Observable, _MetaObservable, Disposable,\n                              ObservableStopError, ObservableFetchError,\n                              ObservableSource, ObservableOperator)\n\nfrom . import observable_sources\nfrom . import observable_operators\nfrom . import observable_promise\n\n\n__all__ = ['Observable', '_MetaObservable', 'Disposable',\n           'ObservableStopError', 'ObservableFetchError',\n           'ObservableSource', 'ObservableOperator']\n"], "anpylar.module": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom browser import document, window\nimport browser.ajax\n\nfrom . import config as aconfig\nfrom . import binding\nfrom .component import Component\nfrom . import html\nfrom .service import Service\nfrom . import router\nfrom . import stacks\n\nfrom .modbase import _MetaMod, _ModBase\n\n__all__ = ['Module']\n\n\ndef logout(*args, **kwargs):\n    if 0:\n        print(*args, **kwargs)\n\n\nclass _MetaModule(_MetaMod):\n    '''\n    Metaclass for Module which prepares the class during creation (for example\n    looking for defined services and instantiation by using the appropriate\n    kwargs automatically for the pre-defined values in the class\n    '''\n\n    def __call__(cls, *args, **kwargs):\n        # scan for kwargs that meet class attributes\n        autokwargs = {k: v for k, v in kwargs.items() if hasattr(cls, k)}\n        for k in autokwargs:\n            kwargs.pop(k)\n\n        self = cls.__new__(cls, *args, **kwargs)  # create\n\n        self._module = self  # to mimic components\n        self._children = []\n\n        child = bool(stacks.modules)\n        if not child:\n            stacks.modules.append(self)  # add as last created module\n            self._parent = None\n        else:\n            self._parent = stacks.modules[-1]\n\n        for k, v in autokwargs.items():  # set the values in the instance\n            setattr(self, k, v)  # before going to init\n\n        # choose the namespace under which services will be placed\n        if not self.service_ns:\n            service_ns = self\n            self._service_ns = None\n        else:\n            class Service_PlaceHolder:\n                pass  # simple attribute placeholder\n\n            self._service_ns = service_ns = Service_PlaceHolder()\n            if self.service_ns is True:  # specific check for True\n                self._s = service_ns\n            else:\n                setattr(self, self.service_ns, service_ns)\n\n        # Instantiate and place services under the selected namespace\n        for name, service in self.services.items():\n            if issubclass(service, (Service,)):\n                s = service(self, self)\n            else:\n                s = service()\n                s._module = self._module\n                s._parent = self\n\n            setattr(service_ns, name, s)\n\n        self._caching = {}\n\n        if not child:\n            if self.modules:\n                if not isinstance(self.modules, (list, tuple)):\n                    submods = [self.modules]\n                else:\n                    submods = self.modules\n\n                isubmods = [submod() for submod in submods]\n            else:\n                isubmods = []\n\n        if not child:\n            # over class attr\n            self.router = self.router_cls(self, isubmods, self.routes)\n            document.body._comp = self  # Set itself as main parent\n\n        _cachename = self.cachename\n        if not _cachename:\n            _cachename = '{}.{}'.format(self.__class__.__module__,\n                                        self.__class__.__name__)\n\n        self._cachename_style = '{}.{}'.format(_cachename, 'style')\n        self._stylerer(document.head)  # need router support, not before\n        self.render(document.head)\n\n        self.__init__(*args, **kwargs)\n\n        if not child:\n            # Remove any overlay present to compensate loading time\n            ov_id = aconfig.module.loading_overlay_id\n            ov_style_id = ov_id + '-style'\n            for dom_id in [ov_id, ov_style_id]:\n                try:\n                    del document[dom_id]\n                except KeyError:\n                    pass\n\n            # Auto-generate DOMNodes, which will kick-start any associated comp\n            Component._visit_nodes(document.body)\n\n            comps = self.components\n            try:\n                if issubclass(comps, Component):\n                    comps = [comps]\n            except TypeError:\n                pass  # issubclass failed because \"comps\" is not a class\n\n            for comp in comps:\n                # Check if components in bootstrap have to still be rendered\n                if not document.select(comp.selector):\n                    t = html._tagout(comp.selector)  # render comp\n                    t._comp._loaded()\n\n            redir = document.query.getvalue('route')\n            self.router._routing(redir=redir, recalc=bool(redir))\n\n        return self\n\n\nclass Module(_ModBase, metaclass=_MetaModule):\n    '''\n    A *Module* is the main control unit for several components, which for\n    example will all access a shared service defined in the module.\n\n    A *Module* can hosts *sub-Modules* which will be either specified through\n    ``Modules`` or with *routes*\n\n    The module is responsible for instantiating the one-and-only ``router``\n    instance\n\n    Attributes:\n\n      - ``bindings ({})``:\n\n        A dictionary containing the name and default value of attributes for\n        the class which will also automatically add bound ``Observables``\n\n        The observables will have a ``_`` (underscore) character appended.\n\n        Setting the value of the attribute will trigger the observable and\n        therefore any actions/subscriptions associated with it. Example:\n\n            bindings = {'myattr': 'myvalue'}\n\n        will create:\n\n          - An attribute ``myattr`` which defaults to ``myvalue``\n\n          - An observable ``myattr_``\n\n      - ``services ({})``:\n\n        A dictionary containing the name and service class for services defined\n        for this and any child component of it\n\n            services = {'myservice': MyService}\n\n      - ``service_ns (False)``:\n\n        If ``False``, services will be added as direct attributes of the\n        instance with the name specified in the ``services`` declaration.\n\n        If ``service_ns`` is:\n\n            - ``True``: the declared ``services`` will be reachable under the\n              attribute ``self._s.myservice``\n\n              This is meant to separate the services from the rest of the\n              attributes.\n\n            - A ``string``, the declared ``services`` will be reachable under\n              the attribute ``self.{value of the string}.myservice``. I.e.: for\n              a value of ``services_here``, then a service would be reachable\n              as::\n\n                self.services_here.myservice\n\n      - ``modules ([])``:\n\n        A single item or an iterable (*list/tuple*) containing sub-modules\n        which will fall under the control of this module\n\n        Sub-modules won't actually act as full control units for components,\n        because they won't, for example, instantiate a ``router`` instance\n\n      - ``components ([])``:\n\n        A single item or an iterable (*list/tuple*) containing components that\n        will be instantiated during start-up. This is usually a single\n        component or even no component at all to let the router auto-output an\n        outlet and decide which components to load with the defined routes\n\n      - ``routes ([])``:\n\n        The list of routes the module will pass to the router. The routes will\n        be extended with children routes coming from sub-modules and\n        ``load_children`` definitions\n\n      - ``router``\n\n        Attribute which points to the router instance in charge of the\n        application. Meant for components.\n\n      - ``router_cls (router.Router)``\n\n        Class attribute which holds the class to be instantiated as the one and\n        only *router* instance\n    '''\n    modules = []\n    components = []  # components to bootstrap\n    service_ns = False\n    services = {}  # services offered to all the ecosystem (name: service)\n    routes = []  # routes definition (list of dict)\n    router_cls = router.Router\n\n    cachename = None\n    cachesheets = True  # keep internal cache of the fetched stylepath\n    _styled = set()  # Flag for style delivered to the head\n\n    stylepath = None\n    stylesheet = ''\n\n    def render(self, node):\n        pass\n\n    def _get_cid_name(self):\n        return ''  # to install at the highest level global\n\n    def cache_add(self, name, value):\n        # Used by components to cache html and sheets\n        self._caching[name] = value\n\n    def cache_get(self, name):\n        # Used by components to retrieve cached html and sheets\n        return self._caching.get(name, None)\n\n    def __getattr__(self, name):\n        if not name.startswith('__'):\n            if self._parent is not None:\n                return getattr(self._parent, name)\n\n        return super().__getattr__(name)\n"], "anpylar.version": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\n\n__version__ = '1.1.3'\n\n__tversion__ = tuple(int(x) for x in __version__.split('.'))\n"], "anpylar.timer": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nimport browser.timer as timer\n\n\n__all__ = ['call_soon', 'call_delayed', 'call_cancel']\n\n\ndef call_soon(cb, *args, **kwargs):\n    if not args and not kwargs:\n        return timer.set_timeout(cb, 0)\n\n    return timer.set_timeout(lambda: cb(*args, **kwargs), 0)\n\n\ndef call_delayed(tout, cb, *args, **kwargs):\n    if not args and not kwargs:\n        return timer.set_timeout(cb, tout)\n\n    return timer.set_timeout(lambda: cb(*args, **kwargs), tout)\n\n\ndef call_cancel(t):\n    return timer.clear_timeout(t)\n"], "anpylar.component": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom browser import document, window\nimport browser.ajax\n\nfrom . import binding\nfrom . import html\nfrom .observable import Observable\nfrom .promise import Promise\nfrom .service import Service\nfrom . import stacks\nfrom . import utils\n\nfrom .modbase import _MetaMod, _ModBase\n\n__all__ = ['Component', 'ComponentInline']\n\n\n_COMPCOUNT = utils.count(1)\n\n_CIDCOUNT = utils.count(1)\n\n\nclass _MetaComponent(_MetaMod):\n    def __init__(cls, name, bases, dct, **kwds):\n        # Must be done here, because in new the factory is not there ... only\n        # the class dict. This is a \"particularity\" of brython\n        super().__init__(name, bases, dct, **kwds)\n\n        cid = str(next(_COMPCOUNT))\n        setattr(cls, '_cid', cid)\n\n        selector = dct.get('selector', None)\n        if not selector:\n            autosel = []\n            lastlower = False\n            for x in name:\n                if x.isupper():\n                    if lastlower:\n                        autosel.append('-')\n                    autosel.append(x.lower())\n                    lastlower = False\n                else:\n                    autosel.append(x)\n                    lastlower = x.islower()\n\n            # Add counter to make unique (same class name in diff module)\n            autosel.append('-')\n            autosel.append(cid)\n\n            dct['selector'] = selector = ''.join(autosel)\n            setattr(cls, 'selector', selector)\n\n        html._customize_tag(selector, dotag=True, component=cls)\n\n    def __call__(cls, *args, **kwargs):\n        htmlnode = stacks.htmlnodes[-1]\n        if htmlnode._comp is not None:\n            # rendered inside another component, send tagout which will\n            # piggyback on this\n            tag = cls._tagout(_compargs=args, _compkwargs=kwargs)\n            return tag._comp\n\n        # scan for kwargs that meet class attributes\n        autokwargs = {k: v for k, v in kwargs.items() if hasattr(cls, k)}\n        for k in autokwargs:\n            kwargs.pop(k)\n\n        self = cls.__new__(cls, *args, **kwargs)  # create\n\n        self._children = []\n\n        # Find enclosing nodes, module and parent component\n        self._htmlnode = htmlnode\n        self._module = stacks.modules[-1]\n        self._parent = htmlnode._elparent._comp\n        parent_module = self._parent._module\n        if self._module != parent_module:\n            self._parent = self._module\n\n        self._parent._children.append(self)\n\n        for k, v in autokwargs.items():  # set the values in the instance\n            setattr(self, k, v)  # before going to init\n\n        # choose the namespace under which services will be placed\n        if not self.service_ns:\n            service_ns = self\n        else:\n            class Service_PlaceHolder:\n                pass  # simple attribute placeholder\n\n            service_ns = Service_PlaceHolder()\n            if self.service_ns is True:  # specific check for True\n                self._s = service_ns\n            else:\n                setattr(self, self.service_ns, service_ns)\n\n        # Instantiate and place services under the selected namespace\n        for name, service in self.services.items():\n            if issubclass(service, (Service,)):\n                s = service(self, self._module)\n            else:\n                s = service()\n                s._module = self._module\n                s._parent = self\n\n            setattr(service_ns, name, s)\n\n        _cachename = self.cachename\n        if not _cachename:\n            _cachename = '{}.{}'.format(self.__class__.__module__,\n                                        self.__class__.__name__)\n\n        self._cachename_style = '{}.{}'.format(_cachename, 'style')\n        self._cachename_html = '{}.{}'.format(_cachename, 'html')\n\n        self.__init__(*args, **kwargs)\n\n        return self\n\n\nclass Component(_ModBase, metaclass=_MetaComponent):\n    '''A *Component* controls the appearance and elements inside a patch of the\n    screen\n\n    It can render the elements programatically or directly with html content\n\n    Attributes:\n\n      - ``bindings ({})``:\n\n        A dictionary containing the name and default value of attributes for\n        the class which will also automatically add bound ``Observables``\n\n        The observables will have a ``_`` (underscore) character appended.\n\n        Setting the value of the attribute will trigger the observable and\n        therefore any actions/subscriptions associated with it. Example:\n\n            bindings = {'myattr': 'myvalue'}\n\n        will create:\n\n          - An attribute ``myattr`` which defaults to ``myvalue``\n\n          - An observable ``myattr_``\n\n      - ``services ({})``:\n\n        A dictionary containing the name and service class for services defined\n        for this and any child component of it\n\n            services = {'myservice': MyService}\n\n      - ``service_ns (False)``:\n\n        If ``False``, services will be added as direct attributes of the\n        instance with the name specified in the ``services`` declaration.\n\n        If ``service_ns`` is:\n\n            - ``True``: the declared ``services`` will be reachable under the\n              attribute ``self._s.myservice``\n\n              This is meant to separate the services from the rest of the\n              attributes.\n\n            - A ``string``, the declared ``services`` will be reachable under\n              the attribute ``self.{value of the string}.myservice``. I.e.: for\n              a value of ``services_here``, then a service would be reachable\n              as::\n\n                self.services_here.myservice\n\n      - ``router``\n\n        Attribute which points to the router instance in charge of the\n        application\n\n      - ``route``\n\n        Attribute which contains the current active route snapshot\n\n      - ``selector (None)``\n\n        The selector is the name of the html tag under which the component is\n        rendered and controls elements.\n\n        If ``None``, the name will be automatically derived from the name of\n        the class\n\n      - ``htmlpath (True)``\n\n        Path to a file containing the html content.\n\n        If ``True`` the name of the file will be derived automatically from the\n        class name, i.e.: *MyComponent* -> *my_component.html*. In this case\n        the file has to be placed at the same level in the file hierarchy as\n        the python module in which the component class is defined.\n\n        To derive the name: underscores will be placed in the upper/lower-case\n        boundaries, everything will be lowercased and the extension ``.html``\n        will be appended.\n\n        If it contains a *name* (string), this will be used to fetch the file\n        from the server (or from a virtual file system if the app is delivered\n        as a package)\n\n        This takes precedence over the ``render`` method.\n\n        After loading, the ``render`` method will be called with the node under\n        which the content has been loaded\n\n      - ``htmlsheet (None)``\n\n        **This takes precedence over ``htmlpath``.**\n\n        If not ``None``, this will then contain html content in text format,\n        which will be used to render the patch\n\n        If ``None``, the name will be automatically derived from the name of\n        the class.\n\n        After loading, the ``render`` method will be called with the node under\n        which the content has been loaded\n\n      - ``stylepath (True)``\n\n        Path to a file containing the style sheet.\n\n        If ``True`` the name of the file will be derived automatically from the\n        class name, i.e.: *MyComponent* -> *mycomponent.css*. In this case the\n        file has to be placed at the same level in the file hierarchy as the\n        python module in which the component class is defined\n\n        To derive the name: underscores will be placed in the upper/lower-case\n        boundaries, everything will be lowercased and the extension ``.css``\n        will be appended.\n\n        If it contains a *name* (string), this will be used to fetch the file\n        from the server (or from a virtual file system if the app is delivered\n        as a package)\n\n        This takes precedence over the ``stlyer`` method.\n\n        After loading, the ``html`` method will be called with the node under\n        which the content has been loaded\n\n      - ``stylesheet (None)``\n\n        If not ``None``, this will then contain a style sheet in text format,\n        which will be used to control the styles of the elements rendered by\n        the component\n\n        **This takes precedence over ``stylepath``**\n\n      - ``cachesheets (True)``\n\n        If ``True``, loaded html content and style sheets will be cached,\n        rather than fetched again\n\n      - ``cacheable (True)``\n\n        If ``True``, the component will not be destroyed and recreated each\n        time. Setting it to ``False`` forces destruction and recreation\n\n    '''\n    cacheable = True  # kept as in between routing or re-created\n    cachesheets = True  # keep internal cache of the fetched stylepath\n    _styled = set()  # Flag for style delivered to the head\n    cachename = None\n    selector = None  # selector tag to apply if any\n    htmlpath = True  # name or autoname (True) of htmlpath\n    htmlsheet = None  # html template\n    stylesheet = None  # name or autoname (True) of stylepath\n    stylepath = True  # name or autoname (True) of stylepath\n\n    service_ns = False\n    services = {}  # name:service of services at component level\n\n    _parent = None  # parent component or module\n    _module = None  # module in which the component lives\n\n    _cid = 0  # component id\n\n    def __getattr__(self, name):\n        if name.startswith('__'):\n            return super().__getattr__(name)\n\n        # During __init__ attributes that have to up the chain may be sought,\n        # but the parent may be unknown. This forces this check to make sure it\n        # makes it up to the module\n        try:\n            return getattr(self._parent, name)\n        except AttributeError:\n            pass\n\n        e = '{} not found in {} nor in its services or hierarchy'. \\\n            format(name, self.__class__.__name__)\n        raise AttributeError(e)\n\n    def __setattr__(self, name, value):\n        # Attribute not found using the regular methods\n        if name[-1] == '_':\n            if isinstance(value, Observable):\n                super().__setattr__(name, value)  # special: pointer creation\n                return\n\n            name1 = name[:-1]\n            if name1 in self.bindings:  # see if it belongs to bindings\n                setattr(self, name1, value)  # set in own bindings\n                return\n\n            # send to parent\n            setattr(self._parent, name, value)\n            return\n\n        # new attribute being set, delegate up the chain\n        super().__setattr__(name, value)\n\n    @classmethod\n    def _tagout(cls, *args, **kwargs):\n        return html._tagout(cls.selector, *args, **kwargs)\n\n    def _loaded(self, dochildren=True):\n        self.loaded()\n        if dochildren:\n            for child in self._children:\n                child._loaded(dochildren=dochildren)\n\n    def loaded(self):\n        pass\n\n    def _load(self, loading=True, dochildren=True):\n        self.load(loading=loading)\n        if dochildren:\n            for child in self._children:\n                child._load(loading=loading)\n\n    def _renderer(self, node):\n        self._stylerer(node)\n        with html.render_node(node):\n            promise = self._htmlerer(node)\n            if promise:\n                stacks.comprender.append(promise)\n\n    def _set_html(self, node, text, cache=True, render=True):\n        if text is None:\n            return\n\n        node.set_html(text)\n        with node:  # be parent of domnodes\n            self._visit_nodes(node)  # generate domnode objects\n\n        if cache:\n            if self.cachesheets:\n                self._module.cache_add(self._cachename_html, text)\n\n        # need to reappend to stack, because it is async\n        if render:\n            self.render(node)\n\n    def _htmlerer(self, node):\n        # 1. checked if html was cached and deliver if possible\n        if self.cachesheets:\n            cached_html = self._module.cache_get(self._cachename_html)\n            if cached_html is not None:\n                return self._set_html(node, cached_html, cache=False)\n\n        # Check if html is defined with the component and apply it\n        if self.htmlsheet:\n            return self._set_html(node, self.htmlsheet)  # rets actually \"None\"\n\n        # Check if html has to be fetched, if not render programatically\n        if not self.htmlpath:\n            return self._set_html(node, self.render(node), render=False)\n\n        # prepare the url\n        urlpath = self._get_urlcomps(self.htmlpath, '.html')\n\n        # Check paketized versions\n        txt = self._get_paketized_file(urlpath)\n        if txt is not None:  # paketized forever!\n            return self._set_html(node, txt)\n\n        # render is delayed until a download happenes\n        promise = Promise()\n\n        # Fetch the html\n        def complete(resp):\n            if resp.status == 200 or resp.status == 0:  # 0 from example\n                with html.render_node(node):  # async call, need to insert\n                    self._set_html(node, resp.text)\n\n                promise._resolve(True)\n            else:\n                promise._reject(resp)\n\n        # The URLs in the browser will be those of the \"routes\" (if defined),\n        # that's why the final url has to be a complete one and not simply a\n        # relative one. Hence the call to the router to get it\n        url = self.router._routecalc('', urlpath)\n\n        a = browser.ajax.ajax()\n        a.bind('complete', complete)\n        url += '?v=' + str(window.Date.new().getTime())\n        a.open('GET', url, True)\n        a.send()\n        return promise\n\n    def _can_deactivate(self):\n        # Takes care of calling deactivate and returning an Observable if the\n        # end user method did not\n        ret = self.can_deactivate()\n        if not isinstance(ret, Observable):\n            ret = Observable.of(ret)\n\n        return ret\n\n    def _binder(self, binder, binding, lambdize=True):\n        # To bind binder with binding, but in the local context, so that self,\n        # will actually be this \"self\" and not that belonging to the binder\n        if lambdize:\n            if not binding.startswith('self.'):\n                binding = 'self.' + binding\n\n            k = {'self': self}\n            exec('_l = lambda: ' + binding, k)\n            binder(k['_l'])\n        else:\n            # This supports many more use cases like adding operators to an\n            # observable to subscribe, which should be specifically sought\n            # below, including having to execute calls\n            if not binding.startswith('self.'):\n                binding = 'self.' + binding\n            binder(eval(binding))\n            # s = self\n            # for a in binding.split('.'):\n            #     attr = getattr(s, a)\n            #     s = attr\n            # binder(attr)\n\n    def _fmtter(self, fmtter, *args, **kwargs):\n        # To bind binder with binding, but in the local context, so that self,\n        # will actually be this \"self\" and not that belonging to the binder\n        selfargs = []\n        for a in args:\n            if a.startswith('self.'):\n                selfargs.append(eval(a))\n            else:\n                selfargs.append(eval('self.{}'.format(a)))\n\n        # self evaluation in the dictionary comprehension fails if no prev\n        # evaluation has taken part outside, like in _binder above\n        # selfkw = {k: eval('self.{}'.format(v)) for k, v in kwargs.items()}\n        selfkw = {}\n        for k, v in kwargs.items():\n            if v.startswith('self.'):\n                selfkw[k] = eval(v)\n            else:\n                selfkw[k] = eval('self.{}'.format(v))\n\n        fmtter(*selfargs, **selfkw)\n\n    # End user methods\n    @classmethod\n    def selector_render(cls, *args, **kwargs):\n        '''Used for rendering inside another component'''\n        return cls._tagout(_compargs=args, _compkwargs=kwargs)\n\n    def load(self, loading=True):\n        '''\n        Called when the component is being loaded/unloaded to/from the DOM\n\n        If not overridden, it will\n\n          - call self.loading() when ``loading=True``\n\n          - call self.unloading() when ``loading=False``\n        '''\n        if loading:\n            self.loading()\n        else:\n            self.unloading()\n\n    def loading(self):\n        '''\n        If the method ``load`` is not overridden, this will be called when the\n        component is about to be loaded to the DOM\n        '''\n        pass\n\n    def unloading(self):\n        '''\n        If the method ``load`` is not overridden, this will be called when the\n        component is about to be unloaded from the DOM\n        '''\n        pass\n\n    def styler(self):\n        '''\n        Override this method to return the css to apply to the component. The\n        returned format is just plain text\n        '''\n        pass\n\n    def render(self, node):\n        '''\n        Render programmatically or manipulate loaded html content.\n\n        If ``htmlsheet`` or ``htmlpath`` are defined, this method will\n        be called after the html content has been loaded. The content lives\n        under node.\n\n        In any other case the method is expected to either:\n\n          - render the html content programmatically\n\n        or\n\n          - return text content which will be the html content to be added to\n            the DOM\n\n        The parameter ``node`` is the DOM element under which either the loaded\n        html content can be found or under which the programmatic rendering or\n        returned text will be inserted.\n        '''\n        pass\n\n    def can_deactivate(self):\n        '''\n        Override this method to disallow navigating away from this component\n        (and the associated route)\n\n        Returns: ``True/False`` or an ``Observable`` which will\n        deliver those values.\n\n        If the final evaluated value is ``True`` navigating away is allowed\n        '''\n        return True\n\n    def close_outlet(self):\n        '''\n        To be used to navigate away from the component when it is loaded in a\n        named outlet\n        '''\n        self._load(loading=False)\n        self._routlet.clear()\n\n\nclass ComponentInline(Component):\n    '''This is a simple subclass of ``Component`` which defines\n    ``htmlpath=None`` and ``stylepath=None`` for components that don't have\n    external html and css resources\n    '''\n    stylepath = None\n    htmlpath = None\n"], "anpylar.router": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom browser import document, window\n\nfrom . import config as aconfig\nfrom . import html as html\nfrom . promise import Promise\nfrom . import stacks\nfrom .utils import defaultdict\n\n\n__all__ = ['Route', 'Router']\n\n\nclass HistoryState:\n    '''Holds a pushstate History event, in case pushstate cannot be used'''\n    def __init__(self, redir, **kwargs):\n        self.redir = redir\n        self.state = list(kwargs.items())\n\n\nclass RouteSnapshot(object):\n    '''\n    Contains the details of a route. Used to keep the details of the active\n    route at each moment in time\n\n    Attributes:\n\n      - ``path``: the requested path\n\n      - ``abspath``: the absolute path which is the base href + path\n\n      - ``route_comps``: a list containing the current ``Route`` chain\n\n      - ``params``: a dictionary containing the params for the route\n    '''\n\n    def __init__(self, path, abspath, rcomps, module, **kwargs):\n        self.path = path\n        self.abspath = abspath\n        self.route_comps = rcomps\n        self.module = module\n        self.params = kwargs\n\n\nclass Route(object):\n    '''\n    Contains the details of a route. Used to keep the details of the active\n    route at each moment in time\n\n    Attributes:\n\n      - ``path``: the requested path\n\n      - ``abspath``: the absolute path which is the base href + path\n\n      - ``route_comps``: a list containing the current ``Route`` chain\n\n      - ``params``: a dictionary containing the params for the route\n    '''\n\n    _RIDX = 1\n\n    base = None\n    path = None\n    _rsplit = None\n    redirect_to = None\n    _redir = None\n    path_match = None\n    component = None\n    params = {}\n    active = False\n    can_activate = None\n    outlet = None\n\n    def __str__(self):\n        out = []\n        out.append('-' * 10)\n        out.append('idx:' + str(self.idx))\n        out.append('path:' + self.path)\n        out.append('params:' + str(self.params))\n        out.append('runsplit:' + self._runsplit)\n        out.append('')\n        return '(' + ' ; '.join(out) + ')'\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __eq__(self, other):\n        return self.idx == other.idx\n\n    def __hash__(self):\n        return self.idx\n\n    def __init__(self, module, submods, bref, bsplit, **kwargs):\n        self.params = {}  # instance specific and not class specific\n        self.module = module\n        self.children = []\n\n        self.idx = self._RIDX\n        self.__class__._RIDX += 1\n\n        self.bref = bref\n        self.bsplit = bsplit  # path already split\n\n        for submod in submods:\n            for cr in getattr(submod, 'routes', []):\n                r = Route(submod, [], '', [], **cr)\n                self.children.append(r)\n\n        for k, v in kwargs.items():\n            if k in ['load_children', 'children']:\n                continue\n\n            setattr(self, k, v)\n\n        if self.can_activate:\n            self.can_activate = self.can_activate()\n\n        for cr in kwargs.get('children', []):\n            self.children.append(Route(module, [], '', [], **cr))\n\n        for lchild in kwargs.get('load_children', []):\n            childmod = lchild()\n            for cr in getattr(lchild, 'routes', []):\n                r = Route(childmod, [], '', [], **cr)\n                self.children.append(r)\n\n        self._rsplit = bsplit + self.path.split('/')\n\n        if not self._rsplit[-1]:  # remove trailing / in split\n            self._rsplit.pop(-1)\n\n        self._runsplit = '/'.join(self._rsplit)\n\n        if self.redirect_to:\n            if self.redirect_to[0] != '/':\n                self._redirsplit = bsplit + self.redirect_to.split('/')\n            else:\n                self._redirsplit = self.redirect_to.split('/')\n\n            if not self._redirsplit[-1]:    # remove trailing / in split\n                self._redirsplit.pop(-1)\n\n            self._redir = '/'.join(self._redirsplit)\n\n    def match(self, url, **kwargs):\n        if self.path in ['*', '**']:\n            return [self]\n\n        if not url.startswith(self._runsplit):\n            return []\n\n        rem_url = url[len(self._runsplit):]\n        if rem_url and rem_url[0] == '/':\n            rem_url = rem_url[1:]\n\n        for child in self.children:\n            ret = child.match(rem_url, **kwargs)\n            if ret:\n                return [self] + ret\n\n        # no child took it ... check if the appropriate params are given\n        for p in self.params or {}:\n            if p not in kwargs:\n                return []\n\n        # params check passed ... take it\n        if self.path_match and rem_url:\n            return []\n\n        return [self]\n\n\nclass Router(object):\n    '''\n    Almighty class controlling the routing internals. It is automatically\n    instantiated by the main application *Module*\n\n    Attributes:\n\n      - ``autorouter (True)``:\n\n        If ``True`` and the application components have not issued a\n        *router-outlet*, the router instance will do it.\n\n      - ``selector ('router-outlet')``:\n\n        If ``autorouter`` is ``True`` and the components define no\n        *router-outlet* for the output of a route, the ``selector`` will be\n        issued automatically\n\n      - ``route``\n\n        Contains the ``RouteSnapshot`` corresponding to the active route\n\n      - ``routes``\n\n        A list of the defined ``Routes`` (children routes are reachable inside\n        the ``Route``)\n\n      - ``basehref``\n\n        The automatically calculated base href for the app\n\n    '''\n    autorouter = True  # create router tags automatically (if not present)\n    selector = 'router-outlet'\n\n    _routedivs = {}  # cache components\n    _rreg = defaultdict(list)  # register callbacks for ractive\n\n    def __init__(self, module, submods, routes):\n        self.module = module  # keep reference to main module\n\n        # Find out the root of the main script. This is the href\n        pymodpath = getattr(__BRYTHON__, '$py_module_path')\n        pathname = pymodpath.__main__\n        self._about = pathname == 'about:blank'\n        if self._about:\n            self._history = []\n            self._histidx = -1\n\n        if pathname is not None:\n            _psplit = pathname.split('//', 1)  # skip scheme\n            if len(_psplit) > 1:\n                urlsplit = _psplit[1]\n            else:\n                urlsplit = '/'\n\n            psplit = urlsplit.split('/')[1:-1]  # skip network loc & filenamee\n        else:\n            psplit = []  # no href is possible\n\n        psplit.insert(0, '')  # add leading /\n        self._basehref = self.basehref = bhref = '/'.join(psplit)\n        self._basesplit = psplit\n\n        # Time to process the routes - use class arg\n        self.routes = rt = []\n\n        for submod in submods:\n            for cr in getattr(submod, 'routes', []):\n                r = Route(submod, [], bhref, psplit, **cr)\n                rt.append(r)\n\n        notfound = None\n        for r in routes:\n            if r.get('path', '') in ['*', '**']:\n                notfound = Route(module, [], bhref, psplit, **r)\n            rt.append(Route(module, [], bhref, psplit, **r))\n\n        if notfound:  # make sure notfound is always last\n            rt.append(notfound)\n\n        self._ractive = None  # no route active - module just started\n        self._ractives = []  # route instances\n\n        # register itself to manage state events\n        window.onpopstate = self._onpopstate\n\n    def _onpopstate(self, evt):\n        # pushstate is delicate in what's accepted as state. If there were no\n        # params an empty string (evaluates to False) was passed and we use the\n        # false evaluation to replace it with an empty dict\n        kwargs = {}\n        if evt.state:\n            # a dict(*evt.state) fails with $nat undefined\n            kwargs.update({x: y for x, y in evt.state})\n\n        redir = evt.redir if self._about else None\n        self._routing(popstate=True, redir=redir, params=((), kwargs))\n\n    def _routeregister(self, pathname, cb, *args, **kwargs):\n        # route = self._routecalc(pathname)\n        self._rreg[pathname].append((cb, args, kwargs))\n\n    def _routecalc(self, *args):\n        tail = '/'.join(args)\n        if tail and tail[0] == '/':\n            return '/'.join((self._basehref, tail[1:]))\n\n        # return '/'.join((self._basehref, tail))\n\n        if tail:\n            if self._ractive:\n                return '/'.join((self._ractive, tail))\n\n            return tail\n\n        return self._ractive\n\n    def _route_to(self, cango, pathname, _recalc=True, *args, **kwargs):\n        if not cango:\n            return\n\n        if _recalc:\n            route = self._routecalc(pathname)\n        else:\n            route = pathname\n\n        pparts = route.split('/')\n        skip = False\n        fpparts = []\n        for p in reversed(pparts):\n            if p == '..':\n                skip = True\n            elif skip:\n                skip = False\n            elif p != '.':\n                fpparts.append(p)\n\n        route = '/'.join(reversed(fpparts))\n\n        self._routing(redir=route, params=(args, kwargs))\n\n    def _routing(self, popstate=False, redir=None, recalc=False, params=()):\n        if stacks.comprender:\n            def reroute(val):\n                self._routing(popstate=popstate, redir=redir,\n                              recalc=recalc, params=params)\n\n            comprender = stacks.comprender[:]  # copy list\n            stacks.comprender.clear()  #\n            p = Promise.all(*comprender).then(reroute)\n            if aconfig.router.log_comprender:\n                p.catch(\n                    lambda x: print(\n                        'Router: Waiting for component rendering failed:', x\n                    )\n                )\n            return\n\n        if not redir:\n            if not self._about:\n                pathname = document.location.pathname\n            else:\n                pathname = '/'\n\n            psplit = pathname.split('/')\n            if pathname[-1] == '/':\n                psplit.pop(-1)\n            elif pathname.endswith('.html'):\n                psplit.pop(-1)\n\n            punsplit = '/'.join(psplit)\n        else:\n            if recalc:  # redir has been supplied\n                redir = self._routecalc(redir)\n\n            punsplit = redir\n\n        # Get the actual requested path without the baseref\n        punpath = punsplit[len(self._basehref):]\n\n        if params:\n            args, kwargs = params\n        else:\n            args = ()\n            kwargs = {}\n\n        if ';' in punsplit:  # params are being sent\n            # remove before route matching\n            lcolons = punsplit.split(';')\n            punsplit = lcolons[0]  # [:-1]  # remove final /\n            for colon in lcolons[1:]:\n                name, value = colon.split('=')\n                kwargs[name] = value\n\n        for r in self.routes:\n            route_path = r.match(punsplit, **kwargs)\n            if not route_path:\n                continue\n\n            r0 = route_path[0]\n            outlet = r0.outlet\n\n            if not outlet:\n                comp, rout = None, None\n                while self._ractives:\n                    r = self._ractives.pop()\n                    if r in route_path:\n                        self._ractives.append(r)\n                        # comp, rout = self._routedivs.get(r.idx, (None, None))\n                        break  # this doesn't need refresh\n\n                    r.active = False\n                    newcomp, newrout = self._routedivs.get(r.idx, (None, None))\n                    if newcomp:\n                        comp, rout = newcomp, newrout\n\n                if comp is not None:\n                    comp._load(loading=False)\n                    rout.parentNode.clear()  # clear the outlet, not the div\n\n                next_r = route_path[-1]\n                pstate = punsplit\n                if kwargs:\n                    paramstate = ';'.join(\n                        ('='.join((str(k), str(v))) for k, v in kwargs.items()\n                         if k in next_r.params)\n                    )\n\n                    if paramstate:\n                        pstate += ';' + paramstate\n\n                # Passing an empty dict as state (1st arg) later returns an\n                # <Object object> which cannot be used anywhere, hence passing\n                # an empty string\n                if not popstate and not next_r.redirect_to:\n                    # pstate = pstate  # punsplit for no query string\n                    if not self._about:\n                        if kwargs:\n                            lkwargs = list(kwargs.items())\n                            window.history.pushState(lkwargs, '', pstate)\n                        else:\n                            window.history.pushState('', '', pstate)\n                    else:\n                        # Manual mechanism if about:blank is the url\n                        if self._history:\n                            lastpstate = self._history[-1].redir\n                        else:\n                            lastpstate = ''\n\n                        # Push to history only if it changed\n                        if lastpstate != pstate:\n                            hstate = HistoryState(pstate, **kwargs)\n                            self._history.insert(self._histidx + 1, hstate)\n                            self._histidx += 1\n\n                r = next_r  # r is now the route to be activated\n                if r.params:  # transformations may be needed\n                    for name, transform in r.params.items():\n                        if name in kwargs:\n                            kwargs[name] = transform(kwargs[name])\n\n                active_route = RouteSnapshot(punpath, punsplit,\n                                             route_path, r.module, **kwargs)\n\n                self.module.route = self.module.r = self.route = active_route\n                self.module.params = self.module.p = active_route.params\n\n                if len(route_path) == len(self._ractives):\n                    # params update\n                    route = route_path[-1]\n                    # won't loop, route must be active\n                    if route.idx in self._routedivs:\n                        comp, rdiv = self._routedivs[route.idx]\n                        if comp is not None:\n                            comp._load(dochildren=False)\n\n                    return\n\n                lastroute = route_path[-1]\n                if lastroute.redirect_to:\n                    self._routing(redir=lastroute._redir, recalc=True,\n                                  params=params)\n                    return\n\n                node = document  # position 0\n                for route in route_path[1:len(self._ractives)]:\n                    if route.idx in self._routedivs:\n                        _, node = self._routedivs[route.idx]\n\n                if self._ractive in self._rreg:\n                    rreg = self._rreg[self._ractive]\n                    for cb, a, kw in self._rreg[self._ractive]:\n                        cb(False, *a, **kw)\n\n                self._ractive = punsplit\n\n                if punsplit in self._rreg:\n                    for cb, a, kw in self._rreg[punsplit]:\n                        cb(True, *a, **kw)\n\n                rpath = route_path[len(self._ractives):]\n            else:\n                node = document.body  # position 0\n                rpath = route_path\n\n            isoutlet = bool(outlet)\n            for route in rpath:\n                if route.can_activate:\n                    if not route.can_activate.can_activate(active_route):\n                        return\n\n                outlet = route.outlet\n                if not isoutlet:\n                    self._ractives.append(route)\n\n                selector = self.selector\n                if outlet:\n                    selector += '[name=\"{}\"]'.format(outlet)\n                routlet = node.select_one(selector)\n                if not routlet:\n                    if not self.autorouter:\n                        return  # nothing can be done\n\n                    if not outlet:\n                        routlet = html._routeout(self.selector)\n                    else:\n                        routlet = html._routeout(self.selector, name=outlet)\n\n                # load (or reload) the node\n                rdiv = None\n                if route.idx in self._routedivs:\n                    comp, rdiv = self._routedivs[route.idx]\n                    if comp is not None:\n                        comp._load(dochildren=False)\n                        routlet._comp._children = [rdiv._comp]\n                        routlet <= rdiv\n                        comp._loaded()\n                else:\n                    # With auto-instantiation, the code from above would\n                    # duplicate a component. Once due to instantiation and a\n                    # 2nd one because of the tagout\n                    stacks.modules.append(route.module)\n                    if route.component is not None:\n                        with html.render_node(routlet):\n                            rdiv = html._routeout(route.component.selector)\n                        comp = rdiv._comp\n                        # children do it for themselves during creation\n                        routlet._comp._children = [comp]\n                        comp._routlet = routlet\n                        comp._rdiv = rdiv\n                        comp._load(dochildren=False)\n                        if comp.cacheable:\n                            self._routedivs[route.idx] = (comp, rdiv)\n\n                    stacks.modules.pop()\n\n                if rdiv:\n                    node = rdiv  # update routlet to search only below\n\n            return\n\n    # End user methods\n    def route_to(self, pathname, *args, **kwargs):\n        '''\n        As the name indicates, this method routes to: ``pathname``\n\n          - ``pathname``\n\n            Absolute or relative path. ``.`` and ``..`` are supported as path\n            elements\n\n          - ``args`` and ``kwargs`` will be passed as arguments to the route\n        '''\n        _recalc = kwargs.pop('_recalc', True)\n        ractive = self._ractives[-1] if self._ractives else None\n        if ractive:\n            comp, rout = self._routedivs.get(ractive.idx, (None, None))\n            if comp:\n                ret = comp._can_deactivate()\n                ret.subscribe(\n                    lambda x: self._route_to(\n                        x, pathname, _recalc=_recalc, *args, **kwargs\n                    )\n                )\n                return\n\n        self._route_to(True, pathname, *args, **kwargs)\n\n    def back(self):\n        '''Navigate once backwards'''\n        if self._about:\n            # The first route to be processed will push the initial histidx\n            # value (-1) to 0. We cannot go beyond that route. Hence we use -1\n            # here, because if only one route is there we cannot move 0 - 1 =\n            # -1 and the check fails\n            hidx = self._histidx - 1\n            if hidx >= 0:\n                self._histidx -= 1\n                self._onpopstate(self._history[hidx])\n        else:\n            window.history.back()\n\n    def forward(self):\n        '''Navigate once forward'''\n        if self._about:\n            # We can at most move to the end of the array.\n            hidx = self._histidx + 1\n            if hidx < len(self._history):\n                self._histidx += 1\n                self._onpopstate(self._history[hidx])\n        else:\n            window.history.forward()\n"], "anpylar.stacks": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nimport browser\n\n__all__ = []\n\n_stacks = {}\n\n\ndef get(name, default=[]):\n    if name in _stacks:\n        return _stacks[name]\n\n    _stacks[name] = sname = list(default)\n    return sname\n\n\nmodules = get('modules')\nhtmlnodes = get('html', [browser.document.body])\ncomprender = get('comprender')\n"], "anpylar.utils": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\n__all__ = ['empty', 'deque', 'defaultdict', 'itercount', 'operators']\n\n\ndef logout(*args, **kwargs):\n    print(*args, **kwargs)\n\n\nclass empty(object):\n    def __init__(self, *args, **kwargs):\n        for name, value in kwargs.items():\n            setattr(self, name, value)\n\n    pass  # placeholder to place elements on\n\n\n# Importing defaultdict from plain \"collections\" pulls in several modules and\n# adds over 1s in loading time in 7700HQ processor. Importing it from\n# Javascript's _collections alleviates the situation partially. Defining it\n# makes it faster\nclass defaultdict(dict):\n    def __init__(self, default):\n        super().__init__()\n        self._default = default\n\n    def __missing__(self, key):\n        self[key] = r = self._default()\n        return r\n\n\nclass deque(list):\n    def __init__(self, iterable=None, maxlen=0):\n        self._maxlen = maxlen\n        if iterable is not None:\n            if len(iterable) > maxlen:\n                iterable = iterable[:maxlen]\n\n            args = [iterable]\n        else:\n            args = []\n\n        super().__init__(*args)\n\n    def append(self, item):\n        if self._maxlen and len(self) == self._maxlen:\n            self.pop(0)  # remove from left\n\n        super().append(item)  # append to right\n\n    def appendleft(self, item):\n        if self._maxlen and len(self) == self._maxlen:\n            self.pop()  # default -1, remove from right\n\n        self.insert(0, item)  # append to left\n\n    def popleft(self):\n        return self.pop(0)  # remove and return from left\n\n\n# avoid import from heavy lifting operator module\nclass operators:\n    eq = staticmethod(lambda x, y: x == y)\n    gt = staticmethod(lambda x, y: x > y)\n    ge = staticmethod(lambda x, y: x >= y)\n    lt = staticmethod(lambda x, y: x < y)\n    le = staticmethod(lambda x, y: x <= y)\n\n\ndef itercount(start=0, step=1):\n    while True:\n        yield start\n        start += step\n\n\nclass count:\n    def __init__(self, start=0, step=1):\n        self.start = start - 1\n        self.step = 1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.start += self.step\n        return self.start\n"], "anpylar.promise": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .future import Future, CatchError\nfrom .timer import call_delayed\n\n\n__all__ = ['Promise', 'Future']\n\n\nclass Promise(Future):\n    '''\n    A Promise modelled after the Promises/A+ standard\n    '''\n    def __init__(self, executor=None, reject=None):\n        '''This creates a Promise:\n\n          - if ``reject`` is ``None``, then executor is called with\n            ``executor(promise_resolve, promise_reject)`` where reject and\n            resolve are the callables to be invoked to indicate if the promise\n            has to be resolved or rejected.\n\n          - if ``reject`` is not ``None`` the invocation will be:\n\n            - ``executor(promise_resolve)``\n            - ``reject(promise_reject)``\n\n        If the execution during creation raises an ``Exception``, the promise\n        will be immediately rejected\n        '''\n        super().__init__()\n        if executor:\n            try:\n                if reject is None:\n                    executor(self._resolve, self._reject)\n                else:\n                    executor(self._resolve)\n                    reject(self._reject)\n\n            except Exception as e:\n                self.set_exception(e)\n\n    def _resolve(self, result, timeout=None):\n        if isinstance(result, Future):\n            self._chain(result, timeout)  # add next to chain\n        elif timeout:\n            call_delayed(timeout, lambda: self.set_result(result))\n        else:\n            self.set_result(result)\n\n        return self\n\n    def _reject(self, exception, timeout=None):\n        if isinstance(exception, Future):\n            return self._chain(exception, timeout)  # add next to chain\n        elif timeout:\n            call_delayed(timeout, lambda: self.set_exception(exception))\n        else:\n            self.set_exception(exception)\n\n        return self\n\n    @staticmethod\n    def resolve(value):\n        '''This creates a Promise which is immediately resolved with\n        ``value``'''\n        return Promise(lambda resolve, reject: resolve(value))\n\n    @staticmethod\n    def reject(value):\n        '''This creates a Promise which is immediately rejected with\n        ``value``'''\n        return Promise(lambda resolve, reject: reject(value))\n\n    @staticmethod\n    def all(*promises):\n        '''This creates a Promise which awaits the resolution of all promises\n        passed as arguments. Anything which is not a *promise* is\n        considered to be immediately resolved and the face value taken as the\n        resolution value\n\n        If any of the promises is rejected, the promise will also be rejected\n        with the value of the rejected promise.\n        '''\n        if not promises:\n            return Promise.resolve([])\n\n        count = [None] * len(promises)\n        results = count[:]  # copy\n\n        # Promise that does nothing to start with\n        retpromise = Promise()\n\n        def thener(result, i):\n            results[i] = result\n            count.pop()\n            if not count:  # all have delivered\n                retpromise._resolve(results)\n\n        def catcher(error):\n            retpromise._reject(error)\n\n        for i, promise in enumerate(promises):\n            if isinstance(promise, Promise):\n                promise \\\n                    .then(lambda x, i=i: thener(x, i)) \\\n                    .catch(catcher)\n            else:\n                count.pop()\n                results[i] = promise\n\n        if not count:  # no promises in iterable, resolve immediately\n            return Promise.resolve(results)\n\n        return retpromise  # await resolution\n\n    @staticmethod\n    def race(*promises):\n        '''This creates a Promise which waits until one of the ``promises``\n        passed as arguments ``*promises`` is resolved/rejected and takes the\n        corresponding value for resolution/rejection\n\n        If no arguments are given, the promise will wait forever (because there\n        is no meaningful value for either resolution or rejection)\n\n        If any of the arguments is not a promise, its value will be immediately\n        used for resolving the returned promise.\n\n        Returns a promise\n        '''\n        # Promise that does nothing to start with\n        retpromise = Promise()\n\n        def thener(result):\n            if not retpromise.done():\n                retpromise._resolve(result)\n\n        def catcher(error):\n            if not retpromise.done():\n                retpromise._reject(error)\n\n        to_wait = []\n\n        for promise in promises:\n            if isinstance(promise, Promise):\n                if promise.cancelled():\n                    continue  # no need to wait on this\n\n                if promise.done():\n                    try:\n                        result = promise.result()\n                    except CatchError:\n                        retpromise._reject(promise.exception())\n                    else:\n                        retpromise._resolve(result)\n\n                    # promise is done and has result/exception\n                    to_wait = []  # avoid waiting on any other promise\n                    break  # bail out\n\n                # else wait for the promise\n                to_wait.append(promise)\n            else:\n                # non-promise, resolve and go\n                retpromise._resolve(promise)\n                to_wait = []  # avoid waiting on any promise\n                break  # bail out\n\n        for promise in to_wait:  # to_wait may be empty if resolved/rejected\n            promise.then(thener).catch(catcher)\n\n        return retpromise  # return the promise to wait on\n\n    def then(self, then, catch=None):\n        '''Takes 1 or 2 arguments.\n\n          - If only the argument ``then`` is provided, it will be invoked with\n            the resolution value if the promise is resolved\n\n          - If ``catch`` is provided, it will be invoked with the rejection\n            value if the promise is rejected\n\n        It returns a promise, to allow chaining\n        '''\n        promise = Promise()  # return a standard promise\n\n        def done_callback(fut):\n            if fut.cancelled():\n                self.cancel()  # copy state\n                return\n\n            try:\n                result = fut.result()  # it's done, we can retrieve\n                if then:\n                    result = then(result)\n\n                if isinstance(result, Future):\n                    promise._chain(result)  # add next to chain\n                else:\n                    promise.set_result(result)  # end of chain, copy\n\n            except (CatchError, Exception) as result:\n                if isinstance(result, CatchError):\n                    result = result.args[0]\n                if catch:\n                    try:\n                        result = catch(result)\n                    except Exception as result:\n                        pass\n\n                    if not isinstance(result, Exception):\n                        promise.set_result(result)\n                    else:\n                        promise.set_exception(result)\n                else:\n                    promise.set_exception(result)\n\n        self.add_done_callback(done_callback)\n        return promise\n\n    def catch(self, catch):\n        '''It invokes internally ``then(None, catch)`` to register the callable\n        ``catch`` for invocation in case the promise is rejected\n\n        It returns a promise, to allow chaining\n        '''\n        return self.then(None, catch)\n\n    def _chain(self, promise, timeout=None):\n        def done_callback(fut):\n            if fut.cancelled():\n                self.cancel()  # copy state\n                return\n\n            try:\n                result = fut.result()  # it's done, we can retrieve\n                if isinstance(result, Future):\n                    self._chain(result, timeout)  # add next to chain\n\n                elif timeout is not None:\n                    call_delayed(timeout, lambda: self.set_result(result))\n                else:\n                    self.set_result(result)\n\n            except Exception as e:\n                if timeout is not None:\n                    call_delayed(timeout, lambda: self.set_exception(e))\n                else:\n                    self.set_exception(e)  # end of chain ... exception\n\n        promise.add_done_callback(done_callback)\n"], "anpylar.tweaks": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nB = __BRYTHON__\n\nB.DOMNodeDict.select_all = B.DOMNodeDict.select\nB.DOMNodeDict.select = B.DOMNodeDict.select_one\n"], "anpylar.http": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom browser import ajax\nfrom .observable import ObservableSource\nfrom .localdata import LocalData\n\n__all__ = ['Http', 'HttpException']\n\n\nclass HttpException(Exception):\n    '''\n        A class representing a HTTPRequest error\n    '''\n    def __init__(self, request):\n        super().__init__(request)  # allow storage in args\n        self.req = request\n\n\nclass HttpRequest(ObservableSource):\n    '''\n        A class representing a Future HTTPRequest result.\n    '''\n    def __init__(self, caller, method, url, headers=None, data=None,\n                 fullresp=False):\n        # self._caller = caller  # not used\n        self._method = method\n        self._url = url\n        self._headers = headers\n        self._data = data\n        self._sid = None\n        self._fullresp = fullresp\n\n    def _subscribed(self, sid, **kwargs):\n        self._sid = sid\n        self._req = req = ajax.ajax()\n        req.bind('complete', lambda r: self._complete_handler(r, sid))\n        req.open(self._method, self._url, True)  # True for async\n        if self._headers:\n            for k, v in self._headers.items():\n                req.set_header(k, v)\n\n        if self._data:\n            req.send(self._data)\n        else:\n            req.send()\n\n    def cancel(self):\n        self._req.abort()\n        self.on_error(False, self._sid)\n\n    def _complete_handler(self, resp, sid):\n        ret = resp if self._fullresp else resp.text\n\n        if 200 <= resp.status < 300:\n            self.on_next(ret, sid)\n        else:\n            # self.on_error(HttpException(resp), sid)\n            self.on_error(ret, sid)\n\n\nclass HttpRequestLocalData(ObservableSource):\n    '''\n        A class representing a Future HTTPRequest result.\n    '''\n    def __init__(self, caller, method, url, headers=None, data=None,\n                 fullresp=False):\n        self._caller = caller\n        self._method = method\n        self._url = url\n        self._data = data\n        self._headers = headers\n        self._fullresp = fullresp\n\n    def _subscribed(self, sid, **kwargs):\n        ldata = self._caller._ldata\n        if ldata is None:\n            for k, v in self._caller._LocalData.items():\n                if self._url.startswith(k):\n                    self._caller._ldata = ldata = v\n                    break\n\n            if ldata is None:\n                self.on_error(\n                    HttpException('No data for path: {}'.format(self._url))\n                )\n                return\n\n        response = ldata(self._method, self._url, self._headers, self._data)\n        self.on_next(response, sid)\n\n\nclass Http:\n    _RequestClass = HttpRequest\n    _LocalData = {}\n\n    @classmethod\n    def serve(cls, data, index, url='', datacls=LocalData):\n        cls._LocalData[url] = datacls(data, index, url)\n        cls._RequestClass = HttpRequestLocalData\n\n    _ldata = None\n\n    def __init__(self, url='', headers=None, fullresp=False):\n        self._fullresp = fullresp\n        self.url = url\n        if headers:\n            self.headers = {k.lower(): v for k, v in headers.items()}\n        else:\n            self.headers = {}\n\n    def _send(self, method, url, headers, data, fullresp=False):\n        if self.url:\n            if url:\n                url = '/'.join((self.url, url))\n            else:\n                url = self.url\n\n        if method == 'GET' and data is not None:\n            q = ('='.join((str(k), str(v))) for k, v in data.items())\n            qs = '&'.join(q)\n            url += '?' + qs\n\n        if headers:\n            h = self.headers.copy()\n            h.update({k.lower(): v for k, v in headers.items()})\n        else:\n            h = self.headers  # no need to copy and update\n\n        return self._RequestClass(self, method, url, h, data,\n                                  fullresp=self._fullresp)\n\n    def get(self, url='', headers=None, data=None):\n        return self._send('GET', url, headers, data)\n\n    def post(self, url='', headers=None, data=None):\n        return self._send('POST', url, headers, data)\n\n    def put(self, url='', headers=None, data=None):\n        return self._send('PUT', url, headers, data)\n\n    def delete(self, url='', headers=None, data=None):\n        return self._send('DELETE', url, headers, data)\n"], "anpylar": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom . import tweaks\n\nfrom . import config\n\nfrom . import authguard\nfrom . import binding\nfrom . import component\nfrom . import html\nfrom . import html as ht\nfrom . import http\nfrom . import localdata\nfrom . import module\nfrom . import service\nfrom . import observable\nfrom . import promise\nfrom . import timer\n\nfrom .authguard import *\nfrom .binding import *\nfrom .component import *\nfrom .http import *\nfrom .localdata import *\nfrom .module import *\nfrom .observable import *\nfrom .service import *\nfrom .promise import *\nfrom .timer import *\n", 1], "anpylar.authguard": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom . import stacks\n\n\n__all__ = ['AuthGuard']\n\n\nclass _MetaAuthGuard(type):\n    def __new__(meta, name, bases, dct, **kwds):\n        # Scan for services in bases and self and install them\n        srv = {}\n        for b in bases:\n            srv.update(getattr(b, 'services', {}))\n\n        srv.update(dict(dct.pop('services', {})))  # pop/update class services\n        dct['services'] = srv  # install in current dictionay\n\n        return super().__new__(meta, name, bases, dct, **kwds)  # create class\n\n    def __call__(cls, *args, **kwargs):\n        # scan for kwargs that meet class attributes\n        autokwargs = {k: v for k, v in kwargs.items() if hasattr(cls, k)}\n        for k in autokwargs:\n            kwargs.pop(k)\n\n        self = cls.__new__(cls, *args, **kwargs)  # create\n\n        self._module = stacks.modules[-1]\n\n        for k, v in autokwargs.items():  # set the values in the instance\n            setattr(self, k, v)  # before going to init\n\n        # Kickstart any defined services\n        for name, service in self.services.items():\n            setattr(self, name, service())\n\n        self.__init__(*args, **kwargs)\n        return self\n\n\nclass AuthGuard(metaclass=_MetaAuthGuard):\n    services = {}  # services offered to all the ecosystem (name: service)\n\n    def __getattr__(self, name):\n        if not name.startswith('__'):\n            if self._module is not None:\n                return getattr(self._module, name)\n\n        return super().__getattr__(name)\n"], "anpylar.html": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\n\n# sys.modules is needed. Importing just _sys which is pure Javascript saves\n# some initial loading time\n\nimport browser\nimport browser.html\n\nfrom . import stacks\nfrom .utils import defaultdict, count\nfrom . import utils\nfrom .observable import Observable\n\n__all__ = []\n\n\nclass render_node(object):\n    '''Simple context manager wrapper for managing rendering elements'''\n    def __init__(self, node=None):\n        self.node = node  # wrapped node to manage in the context\n\n    def __enter__(self):\n        node = self.node or stacks.htmlnodes[-1]  # current rendering\n        # reappend even if selected to avoid a render_stop from popping it\n        stacks.htmlnodes.append(node)\n        return node\n\n    def __exit__(self, type_, value, tb):\n        if type_ is None:  # no exception raised, do something\n            stacks.htmlnodes.pop(-1)\n            while _el2render:\n                _el2render.pop(-1)._procfuncs()\n\n\nclass _MetaElement(type):\n    def __call__(cls, *args, **kwargs):\n        # must be intercepted here, because it the link has parameters the\n        # object won't be properly stored and retrieved in the HTML element\n        rlink = kwargs.pop('routerlink', None)\n\n        compargs = kwargs.pop('_compargs', ())\n        compkwargs = kwargs.pop('_compkwargs', {})\n\n        self = super().__call__(*args, **kwargs)  # create\n        taglower = getattr(self, 'tagName', '').lower()\n\n        if taglower not in ['script', 'head', 'style']:\n            _el2render.append(self)\n\n        if not hasattr(self, '_elparent'):  # flag to avoid overwriting\n            self._started = False\n            self._elid = next(_ELID)\n            self._elparent = stacks.htmlnodes[-1]\n            self._rlink = rlink\n            self._funcs = defaultdict(list)\n            self._dfuncs = defaultdict(list)\n            self._sargs = defaultdict(list)\n            self._kargs = defaultdict(dict)\n            self._txtmplate = None\n            self._cvals = dict()  # to cache without polluting space\n\n        # Check if this node already has an active comp\n        if self._comp is None:\n            if cls._autocomp is None:\n                if taglower != 'style':\n                    try:\n                        self._comp = _comp = self._elparent._comp\n                    except AttributeError:\n                        self._comp = None\n                if taglower != 'router-outlet':\n                    # mark for styling\n                    try:\n                        self.setAttribute(self._comp._get_cid_name(), '')\n                    except:\n                        pass  # style tag\n            else:\n                with self:\n                    self._comp = cls._autocomp(*compargs, **compkwargs)\n\n                self._comp._renderer(self)\n                # if the component is from autocomp and wrapped it has been\n                # generated by a visit to a node and not by end-user code,\n                # hence the need to issue the call to _load to let it do\n                # whatever it needs\n                if self._wrapped:\n                    self._comp._load()\n\n                # if not wrapped, it has been generated by a call to tagout\n\n            fmtargs = []\n            fmtkwargs = {}\n\n            for attr in self.attributes:\n                name = attr.name\n                value = attr.value\n                n0 = name[0]\n                if n0 == '(':  # reguest to bind\n                    binder = getattr(self._bindx, name[1:-1])\n                    lambdize = value[-1] == ')'\n                    self._comp._binder(binder, value, lambdize=lambdize)\n                elif n0 == '*':\n                    binder = getattr(self, name[1:])\n                    self._comp._binder(binder, value, lambdize=False)\n                elif n0 == '[':\n                    name = name[1:-1]\n                    if not name:\n                        name = value\n                    fmtargs.append(name)\n                elif n0 == '{':\n                    fmtkwargs[name[1:-1]] = value\n                elif n0 == '$':\n                    binder = getattr(self._bind, name[1:-1])\n                    lambdize = value[-1] == ')'\n                    self._comp._binder(binder, value, lambdize=lambdize)\n\n            if fmtargs or fmtkwargs:\n                self._comp._fmtter(self._fmt, *fmtargs, **fmtkwargs)\n\n        if not self._wrapped:\n            if taglower != 'txt':  # anpylar for text templating\n                if self._elparent.children:\n                    self._elparent <= '\\n'  # simulate a real html doc\n            self._elparent <= self  # insert in last item ... parent\n\n        if hasattr(self, 'do_customize'):\n            do_customize = getattr(self, 'do_customize')\n            if do_customize != self:\n                self.do_customize(*args, **kwargs)\n\n        return self\n\n\nclass SuperchargedNode(object, metaclass=_MetaElement):\n    '''\n    The ``SuperchargedNode`` increases the standard powers of a DOM node by\n    providing extra methods and being aware of *Observables*, to which it can\n    subscribe to react to changes.\n\n    It does also provide supercharged attributes with specially prefixed (and\n    suffixed in some cases) attribute names that can provide a small\n    programming interface\n    '''\n    _comp = None\n    _autocomp = None\n\n    _TXT = 'text'\n\n    def __enter__(self):\n        # auto-created nodes were put there before a component had the\n        # chance to parent them, but when rendering a component is in control\n        stacks.htmlnodes.append(self)  # self is parent now\n        return self\n\n    def __exit__(self, type_, value, traceback):\n        stacks.htmlnodes.pop(-1)  # remove itself as parent\n\n    def _ractive(self, status, ractive):\n        cl = self.class_name.split()\n        if status:\n            if ractive not in cl:\n                cl.append(ractive)\n        else:\n            if ractive in cl:\n                cl.remove(ractive)\n\n        self.class_name = ' '.join(cl)\n\n    def _procfuncs(self):\n        self._started = True\n        rlink = self._rlink\n        if rlink is None:\n            self._rlink = rlink = getattr(self, 'routerlink', None)\n\n        if rlink is not None:\n            router = self._comp.router\n            if isinstance(rlink, str):\n                rl = rlink\n                ret = router._routecalc(rl)\n                # self.bind('click', lambda x: router.route_to(rl))\n                self.bind(\n                    'click',\n                    lambda x: router.route_to(ret, _recalc=False)\n                )\n            else:\n                rl, kw = rlink  # must be an iterable with 2 itmes\n                ret = router._routecalc(rl)\n                self.bind(\n                    'click',\n                    lambda x: router.route_to(ret, _recalc=False, **kw)\n                )\n\n            ractive = getattr(self, 'routerlinkactive', None)\n            if ractive:\n                router._routeregister(ret, self._ractive, ractive)\n\n        if self._txtmplate is None:\n            self._txtmplate = getattr(self, self._TXT)\n\n        if not self._txtmplate:\n            self._txtmplate = '{}'  # last option\n\n        with render_node(self):\n            for k, fl in self._funcs.items():\n                for func in fl:\n                    func(*self._sargs[k], **self._kargs[k])\n\n    def __call__(self, val, key, ref):\n        # A key is needed, hence the explicit mentioning ref too retrieve\n        # target arguments\n        sargs = self._sargs[key]\n        kargs = self._kargs[key]\n        # Cache new value\n        if isinstance(ref, int):\n            sargs[ref] = val\n        else:\n            kargs[ref] = val\n\n        if not self._started:\n            return\n\n        if key in self._funcs:\n            fs = self._funcs[key]\n        else:\n            fs = self._dfuncs[key]\n\n        with render_node(self):\n            for f in fs:\n                f(*sargs, **kargs)\n\n    def _subintern(self, func, fargs, fkwargs, delay=False):\n        key = next(_KEY)\n        if not delay:\n            self._funcs[key].append(func)\n        else:\n            self._dfuncs[key].append(func)\n\n        sargs = self._sargs[key]\n        for i, sarg in enumerate(fargs, len(sargs)):\n            if isinstance(sarg, Observable):\n                kw = {'who': self, 'fetch': True}\n                # default ref=i to freeze param in lambda during loop\n                v = sarg.subscribe(lambda x, ref=i: self(x, key, ref), **kw)\n                try:\n                    v = v.get_val()\n                except AttributeError:\n                    v = ''\n\n                sargs.append(v)\n            else:\n                sargs.append(sarg)\n\n        kargs = self._kargs[key]\n        for name, karg in fkwargs.items():\n            if isinstance(karg, Observable):\n                kw = {'who': self, 'fetch': True}\n                v = karg.subscribe(lambda x, ref=name: self(x, key, ref), **kw)\n                try:\n                    v = v.get_val()\n                except AttributeError:\n                    v = ''\n\n                kargs[name] = v\n            else:\n                kargs[name] = karg\n\n        return self\n\n    def _sub(self, func, *args, **kwargs):\n        return self._subintern(func, args, kwargs, delay=False)\n\n    def _subdelay(self, func, *args, **kwargs):\n        return self._subintern(func, args, kwargs, delay=True)\n\n    def _fmtrecv(self, *args, **kwargs):  # call is in kwargs\n        setattr(self, self._TXT, self._txtmplate.format(*args, **kwargs))\n\n    def _fmt(self, *args, **kwargs):\n        '''\n        Use it as: ``_fmt(*args, **kwargs)``\n\n        Any of the ``args`` or ``kwargs`` can be an observable to which the\n        method will automatically subscribe (like for example the observables\n        created by *bindings* in components)\n\n        This will format the text field of the tag using the standard *Format\n        Mini Language Specification* of Python.\n\n        Any ``arg`` will format the non-named templates ``{}`` sequentially and\n        named arguments will target named templates ``{name}``\n\n        When using observables, the formatting will update itself with each new\n        value delivered by the observable.\n        '''\n        return self._sub(self._fmtrecv, *args, **kwargs)\n\n    def _fmtfunc(self, func, *args, **kwargs):\n        return self._sub(\n            lambda *a, **kw: self._fmtrecv(func(*a, **kw)),\n            *args, **kwargs\n        )\n\n    @property\n    def _render(self):\n        '''\n        Use it as::\n\n          _render(callbackk, *args, **kwargs)\n\n        Any of the ``args`` or ``kwargs`` can be an observable to which the\n        method will automatically subscribe (like for example the observables\n        created by *bindings* in components)\n\n        This will call at least one ``callback`` (for the initial rendering\n        below the node)\n\n        If any subscription has been made to observable, the rendering will be\n        re-done with each new value passed by the observable\n        '''\n        return _RenderHelper(self)\n\n    def _pub(self, event, *args, **kwargs):\n        self.bind(event, lambda evt: self._pubsend(*args, **kwargs))\n        return self\n\n    def _pubattr(self, event, attr, *args, **kwargs):\n        self.bind(event, lambda evt: self._pubsendattr(attr, *args, **kwargs))\n        return self\n\n    def _pubsub(self, event, func, *args, **kwargs):\n        self._sub(func, *args, **kwargs)\n        return self._pub(event, *args, **kwargs)\n\n    def _pubsend(self, *args, **kwargs):\n        val = getattr(self, self._TXT)\n        for binding in args:\n            binding(val, self)\n\n    def _pubsendattr(self, attr, *args, **kwargs):\n        val = getattr(self, attr)\n        for binding in args:\n            binding(val, self)\n\n    @property\n    def _fmtevt(self):\n        '''\n        Use it as: ``_fmtevt(event, *args, **kwargs)`` or\n        ``_fmtevt.event(*args, **kwargs)``\n\n        Any of the ``args`` or ``kwargs`` can be an observable to which the\n        method will automatically subscribe (like for example the observables\n        created by *bindings* in components)\n\n        This binds a generic event to notify the observables which at the same\n        time are using for formatting the content of the tag\n        '''\n        return _FmtEvtHelper(self)\n\n    @property\n    def _fmtvalue(self):\n        '''\n        Alias: ``_fmtval``\n\n        Use it as: ``_fmtvalue(*args, **kwargs)``\n\n        Any of the ``args`` or ``kwargs`` can be an observable to which the\n        method will automatically subscribe (like for example the observables\n        created by *bindings* in components)\n\n        This is meant for tags like <input> which have a value field. A binding\n        can be passed (just like in _fmt) to format the text in the field.\n\n        At the same time when the value in the field changes the binding will\n        be fed with the new value.\n\n        Effectively, this binds the binding bi-directionally for updating the\n        field and kicking the observable\n        '''\n        return _FmtValHelper(self)\n\n    _fmtval = _fmtvalue\n\n    @property\n    def _bind(self):\n        '''\n        Allows binding to an event, with either\n\n          - ``element._bind(event, callback, *args, **kwargs)``\n\n        or\n\n          - ``element._bind.event(callback, *args, **kwargs)``\n\n        The callback will receive the *event* as the first argument as in\n\n          - ``callback(event, *args, **kwargs)``\n        '''\n        return _BindHelper(self)\n\n    @property\n    def _bindx(self):\n        '''\n        Allows binding to an event, without receiving it in the callback\n\n          - ``element._bindx(event, callback, *args, **kwargs)``\n\n        or\n\n          - ``element._bind.event(callback, *args, **kwargs)``\n\n        The callback will **NOT** receive the *event* as the first argument.\n\n          - ``callback(*args, **kwargs)``\n        '''\n        return _BindXHelper(self)\n\n    @property\n    def _attr(self):\n        '''\n        Controls the presence/absence of an attribute inside the element\n\n        It can be used as in\n\n          - ``element._attr(name, trigger, on, off)``\n\n        or\n\n          - ``element._attr.name(trigger, on, off)``\n\n        The arguments:\n\n          - ``trigger``: value or observable which controls if ``show`` or\n            ``hide`` will be used\n\n          - ``on``: value to activate display of the element\n\n          - ``off``: value to hide the element\n\n        *Note*: if ``on`` and ``off`` are not provided, the defaults will be\n         ``\"true\"`` and ``\"\"`` (empty string)\n        '''\n        return _AttributeHelper(self)\n\n    @property\n    def _style(self):\n        '''\n        Controls the presence/absence of an attribute inside the element's\n        *style*\n\n        It can be used as in\n\n          - ``element._style(name, trigger, on, off)``\n\n        or\n\n          - ``element._style.name(trigger, on, off)``\n\n        The arguments:\n\n          - ``trigger``: value or observable which controls if ``on`` or\n            ``off`` will be used\n\n          - ``on``: value to activate display of the element\n\n          - ``off``: value to hide the element\n\n        *Note*: if ``on`` and ``off`` are not provided, the defaults will be\n         ``\"true\"`` and ``\"\"`` (empty string)\n        '''\n        return _StyleHelper(self)\n\n    def _display(self, trigger, show='', hide='none'):\n        '''\n        Controls the *display* value inside the *style* on an element.\n\n          - ``trigger``: value or observable which controls if ``show`` or\n            ``hide`` will be used\n\n          - ``show`` (default: ''): value to activate display of the element\n\n          - ``hide`` (default: 'none'): value to hide the element\n\n        Returns a reference to the *element*\n        '''\n        def st(val):\n            setattr(self.style, 'display', show if val else hide)\n\n        return self._sub(st, trigger)\n\n    def _display_toggle(self, onoff=None):\n        '''\n        Toggles/controls the display status of the element\n\n          - ``onoff`` (default: ``None``): if ``None`` the display status will\n            be toggled. If either ``True`` or ``False``, the display status\n            will be set to on or off respectively\n\n        Returns a reference to the *element*\n        '''\n        curdisplay = self.style.display\n\n        if onoff is None:  # toggle modus\n            if curdisplay is 'none':\n                nextdisplay = self._cvals.get('lastdisplay', '')\n                if nextdisplay == 'none':\n                    nextdisplay = ''\n            else:\n                nextdisplay = 'none'\n\n            self.style.display = nextdisplay\n\n        elif isinstance(onoff, str):\n            self.style.display = onoff\n        else:\n            if onoff:\n                if curdisplay == 'none':\n                    self.style.display = self._cvals.get('lastdisplay', '')\n            else:\n                if curdisplay != 'none':\n                    self.style.display = 'none'\n\n        self._cvals['lastdisplay'] = curdisplay\n        return self\n\n    @property\n    def _class(self):\n        '''\n        Controls the presence/absence of an attribute inside the element's\n        *class*\n\n        It can be used as in\n\n          - ``element._class(name, trigger)``\n\n        or\n\n          - ``element._class.name(trigger)``\n\n        The arguments:\n\n          - ``trigger``: value or observable which controls if ``name`` is part\n            of the class or not\n        '''\n        return _ClassHelper(self)\n\n\nclass _HelperBase:\n    helper = None\n\n    def __init__(self, target, helper=None):\n        if helper is not None:\n            self.helper = helper  # avoid overwriting default values\n        self.target = target\n\n    def __getattr__(self, name):\n        self.helper = name\n        return self\n\n\nclass _BindHelper(_HelperBase):\n    def __call__(self, func, *args, **kwargs):\n        evt = self.helper\n        if evt is None:\n            evt = args[0]\n            args = args[1:]\n\n        return self.target.bind(evt, lambda e: func(e, *args, **kwargs))\n\n\nclass _BindXHelper(_HelperBase):\n    def __call__(self, func, *args, **kwargs):\n        evt = self.helper\n        if evt is None:\n            evt = args[0]\n            args = args[1:]\n\n        return self.target.bind(evt, lambda e: func(*args, **kwargs))\n\n\nclass _AttributeHelper(_HelperBase):\n    def __call__(self, trigger, on=None, off=None, *args, **kwargs):\n        helper = self.helper\n        if helper is None:\n            helper = trigger\n            trigger = on\n            on = off\n            off = args[0]\n\n        if on is None:\n            on = 'true'\n\n        if off is None:\n            off = ''\n\n        def st(val, *args, **kwargs):\n            stval = on if val else off\n            setattr(self.target, helper, stval)\n\n        return self.target._sub(st, trigger)\n\n\nclass _StyleHelper(_HelperBase):\n    def __call__(self, trigger, on=None, off=None, *args, **kwargs):\n        helper = self.helper\n        if helper is None:\n            helper = trigger\n            trigger = on\n            on = off\n            off = args[0]\n\n        if on is None:\n            on = 'true'\n\n        if off is None:\n            off = ''\n\n        def st(val, *args, **kwargs):\n            stval = on if val else off\n            try:\n                setattr(self.target.style, helper, stval)\n            except Exception as e:\n                pass\n\n        return self.target._sub(st, trigger)\n\n\nclass _DisplayHelper(_HelperBase):\n    helper = 'display'\n\n    def __call__(self, trigger, show='', hide='none'):\n        def st(val, *args, **kwargs):\n            stval = show if val else hide\n            setattr(self.target.style, self.helper, stval)\n\n        return self.target._sub(st, trigger)\n\n\nclass _ClassHelper(_HelperBase):\n    helper = []\n\n    def __getattr__(self, name):\n        self.helper.append(name)\n        return self\n\n    def __call__(self, trigger, *args, **kwargs):\n        if not self.helper:\n            self.helper.append(trigger)\n            trigger = args[0]\n\n        return self.target._sub(self._toggle_action, trigger)\n\n    def _toggle_action(self, val):\n        cname = self.target.class_name\n        cs = cname.split(' ') if cname else []\n\n        for c in self.helper:\n            if val:\n                if c not in cs:\n                    cs.append(c)\n            else:\n                try:\n                    cs.remove(c)\n                except ValueError:\n                    pass\n\n        self.target.class_name = ' '.join(cs) if cs else ''\n\n\nclass _EvtHelper:\n    evt = None\n\n    def __init__(self, target, evt=None):\n        self.target = target\n        if evt is not None:\n            self.evt = evt\n\n    def __getattr__(self, evt):\n        self.evt = evt\n        return self\n\n    def __call__(self, func, *args, **kwargs):\n        return self.target.bind(self.evt, lambda evt: func(*args, **kwargs))\n\n    def bindx(self, func, *args, **kwargs):\n        return self.target.bind(self.evt, lambda evt: func(*args, **kwargs))\n\n    def bind(self, func, *args, **kwargs):\n        return self.target.bind(self.evt, lambda e: func(e, *args, **kwargs))\n\n\nclass _FmtEvtHelper(_EvtHelper):\n    def __call__(self, *args, **kwargs):\n        self.target._fmt(*args, **kwargs)\n        return self.target._pub(self.evt, *args, **kwargs)\n\n\nclass _FmtValHelper(_FmtEvtHelper):\n    evt = 'input'\n\n    def __call__(self, *args, **kwargs):\n        self.target._fmt(*args, **kwargs)\n        return self.target._pub(self.evt, *args, **kwargs)\n\n\nclass _RenderHelper:\n    def __init__(self, target):\n        self.target = target\n        self._lazy = True\n\n    def __call__(self, func, *args, **kwargs):\n        self.func = func\n        if not self._lazy:\n            return self.target._sub(self._action, *args, **kwargs)\n\n        return self.target._subdelay(self._action, *args, **kwargs)\n\n    def _action(self, *args, **kwargs):\n        self.target.clear()\n        self.func(*args, **kwargs)\n\n    def __getattr__(self, name):\n        if name == 'lazy':\n            self._lazy = True\n            return self\n\n        return super().__getattr__(name)\n\n\ndef _tout(name, *args, **kwargs):\n    try:\n        factory = _thismod.tags[name]\n    except KeyError:\n        factory = _customize_tag(name, True)\n\n    return factory(*args, **kwargs)\n\n\ndef _tagout(name, *args, **kwargs):\n    tout = _tout(name.lower(), *args, **kwargs)\n    if tout._autocomp is not None:\n        tout._comp._load()  # comp was generated, start it\n        pass\n    return tout\n\n\ndef _routeout(name, *args, **kwargs):\n    return _tout(name.lower(), *args, **kwargs)\n\n\ndef _customize_tag(name, dotag=False, component=None):\n    lname = name.lower()\n    dct = _tagmaps[None].copy()\n    dct.update(_tagmaps.get(lname, {}))\n    if dotag:\n        thetag = browser.html.maketag(name)\n    else:\n        thetag = getattr(browser.html, name)\n\n    dct['_autocomp'] = component\n    try:\n        kls = type(lname, (SuperchargedNode, thetag,), dct)\n    except TypeError:\n        return None\n\n    # lower, Lower and LOWER will be reachable\n    for lx in [lname, lname.upper(), lname.capitalize()]:\n        setattr(_thismod, lx, kls)\n        _thismod.tags[lx] = kls\n\n    return kls\n\n\n# Prepare custom functions/tags\n# Override classes to make them lowercase (readability) and add methods\n_thismod = getattr(__BRYTHON__.imported, __name__)\n\ntags = {}  # keep track of all tags\n\n_tag = _tagout\n\n_KEY = utils.count(1)\n_ELID = utils.count(1)\n\ndocument = browser.document\n\n_el2render = []\n\n_tagmaps = {\n    None: {\n        '_TXT': 'text',\n        '_EVT': 'input',\n    },\n\n    'input': {\n        '_TXT': 'value',\n    },\n    'textarea': {\n        '_TXT': 'value',\n    },\n}\n\n\n# customize tags in browser html\nfor tag in browser.html.tags:\n    if tag != 'BODY':\n        _customize_tag(tag)\n\n# This tags has to be customized in advance\nfor x in ['txt', 'router-outlet']:\n    _customize_tag(x, dotag=True)\n\n\n# Override default tags with supercharged ones\n__BRYTHON__.DOMNodeDict.tagsorig = __BRYTHON__.DOMNodeDict.tags\n__BRYTHON__.DOMNodeDict.tags = tags\n"], "anpylar.future": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .timer import call_soon\n\n\n__all__ = ['Future']\n\n\nclass InvalidStateError(Exception):\n    pass\n\n\nclass CancelledError(Exception):\n    pass\n\n\nclass TimeoutError(Exception):\n    pass\n\n\nclass CatchError(Exception):\n    pass\n\n\nclass Future:\n    \"\"\"\n        A class representing the future result of an async action.\n        Implementations should override the :method:`start` method\n        which should start the asynchronous operation. The class will\n        typically register a handler to be run when the operation finishes.\n        This handler then needs to call the base :method:`_finish` method\n        providing it with the :parameter:`result` parameter and\n        :parameter:`status` (which should either be ``Promise.STATUS_FINISHED``\n        in case the operation finished successfully or ``Promise.STATUS_ERROR``\n        if an error happened).\n    \"\"\"\n    STATUS_STARTED = 0\n    STATUS_CANCELED = 1\n    STATUS_FINISHED = 2\n    STATUS_ERROR = 3\n\n    def __init__(self):\n        # self._loop = get_event_loop()\n        self._status = Future.STATUS_STARTED\n        self._result = None\n        self._exception = None\n        self._callbacks = []\n\n    def _schedule_callbacks(self):\n        cbs = self._callbacks[:]  # copy list content\n        self._callbacks = []\n        for cb in cbs:\n            # self._loop.call_soon(cb, self)\n            call_soon(cb, self)\n\n    def cancel(self):\n        \"\"\"Cancel the future and schedule callbacks.\n\n        If the future is already done or cancelled, return False. Otherwise,\n        change the future\u2019s state to cancelled, schedule the callbacks and\n        return True.\n\n        \"\"\"\n        if self._status != Future.STATUS_STARTED:\n            return False\n        self._status = Future.STATUS_CANCELED\n        self._schedule_callbacks()\n        return True\n\n    def cancelled(self):\n        \"\"\"Return True if the future was cancelled.\"\"\"\n        return self._status == Future.STATUS_CANCELED\n\n    def done(self):\n        \"\"\"Return True if the future is done.\n\n        Done means either that a result / exception are available, or that the\n        future was cancelled.\n\n        \"\"\"\n        return self._status != Future.STATUS_STARTED\n\n    def result(self):\n        \"\"\"Return the result this future represents.\n\n        If the future has been cancelled, raises CancelledError. If the\n        future\u2019s result isn\u2019t yet available, raises InvalidStateError. If the\n        future is done and has an exception set, this exception is raised.\n\n        \"\"\"\n        if self._status == Future.STATUS_STARTED:\n            raise InvalidStateError()\n        if self._status == Future.STATUS_CANCELED:\n            raise CancelledError()\n        if self._status == Future.STATUS_ERROR:\n            raise CatchError(self._exception)\n        return self._result\n\n    def exception(self):\n        \"\"\"Return the exception that was set on this future.\n\n        The exception (or None if no exception was set) is returned only if the\n        future is done. If the future has been cancelled, raises\n        CancelledError. If the future isn\u2019t done yet, raises InvalidStateError.\n\n        \"\"\"\n        if self._status == Future.STATUS_STARTED:\n            raise InvalidStateError()\n        if self._status == Future.STATUS_CANCELED:\n            raise CancelledError()\n        if self._status == Future.STATUS_ERROR:\n            return self._exception\n\n    def add_done_callback(self, fn):\n        \"\"\"Add a callback to be run when the future becomes done.\n\n        The callback is called with a single argument - the future object. If\n        the future is already done when this is called, the callback is\n        scheduled with call_soon().\n\n        Use functools.partial to pass parameters to the callback. For example,\n        fut.add_done_callback(functools.partial(print, \"Future:\", flush=True))\n        will call print(\"Future:\", fut, flush=True).\n\n        \"\"\"\n        if self.done():\n            # self._loop.call_soon(fn,self)\n            call_soon(fn, self)\n        else:\n            self._callbacks.append(fn)\n\n    def remove_done_callback(self, fn):\n        \"\"\"Remove all instances of a callback from the \u201ccall when done\u201d list.\n\n        Returns the number of callbacks removed.\n\n        \"\"\"\n        lcbs = len(self._callbacks)\n        self._callbacks = cbs = [cb for cb in self._callbacks if cb != fn]\n        return lcbs - len(cbs)\n\n    def set_result(self, result, noexceptions=False):\n        \"\"\"Mark the future done and set its result.\n\n        If the future is already done when this method is called, raises\n        InvalidStateError.\n\n        \"\"\"\n        if self._status != Future.STATUS_STARTED:\n            if noexceptions:\n                return\n            raise InvalidStateError()\n        self._result = result\n        self._status = Future.STATUS_FINISHED\n        self._schedule_callbacks()\n\n    def set_exception(self, exception, noexceptions=False):\n        \"\"\"Mark the future done and set an exception.\n\n        If the future is already done when this method is called, raises\n        InvalidStateError.\n\n        \"\"\"\n        if self._status != Future.STATUS_STARTED:\n            if noexceptions:\n                return\n            raise InvalidStateError()\n        self._exception = exception\n        self._status = Future.STATUS_ERROR\n        self._schedule_callbacks()\n"], "anpylar.binding": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .observable_attribute import ObservableAttribute\nfrom . import stacks\nfrom .utils import defaultdict\n\n\n__all__ = ['MetaDataBindings', 'DataBindings', 'Model']\n\n\nclass _Binding(object):\n    '''\n    This is a descriptor meant to work as a binding, ie: it does accept\n    *subscriptions* from external which get bound to changes in the value held\n    for each object\n\n    Attributes\n\n      - _name: informative and could be used for debugging. Name of the\n        attribute in the host class\n\n      - default: default value when a class is instantiated\n\n      - cache: holds the current value for each instance plus itself for class\n        lookups\n\n      - subs: a dictionary holding the subscriptions\n    '''\n    def __init__(self, name, default):\n        self._name = name\n        self.default = default\n        self.cache = {None: self}  # for class attribute lookups\n        self.subs = defaultdict(list)  # hold list of subs  per object\n\n    def __get__(self, obj, cls=None):\n        # return cached value or set the default as value\n        return self.cache.setdefault(obj, self.default)\n\n    def __set__(self, obj, val, who=None):\n        # After setting the value for obj, notify subscriptors except notifier\n        self.cache[obj] = val\n        for cb, ptd, whom in self.subs[obj]:\n            # pass the value set by who to the subscriptors\n            if not whom or whom is not who:  # only for those who are not \"who\"\n                # if the pointed to value is wished, retrieve it\n                pval = val if ptd is None else getattr(val, ptd)\n                cb(pval, whom)\n\n    def _notify(self, obj, val, who, ptd):\n        # Used by ObservablePointed points to a final value. After the final\n        # value is set, ObservablePointed lets the descriptor know which value\n        # vas set and for which pointed value. If subscriptors for that ptd\n        # value are available they are notified\n        for cb, _ptd, whom, in self.subs.get(obj, []):\n            if _ptd == ptd and whom is not who:\n                cb(val, whom)\n\n    def subscribe(self, obj, cb, ptd=None, who=None):\n        # A subscription has the following attributes\n        #   - obj: the object hosting this descriptor (instance)\n        #   - who: the subscriptor, which must be a callable\n        #   - ptd: if not None, the subscription is not looking for the value\n        #   of this descriptor, but rather an attribute held by value stored by\n        #   this descriptor for obj\n        #   - *args, **kwargs, the arguments to pass back to the subscriptor\n        self.subs[obj].append((cb, ptd, who))\n\n        ret = self.__get__(obj)  # return the current value held for obj\n        if ptd is not None:\n            ret = getattr(ret, ptd)\n\n        return ret\n\n\n# Name of the attribute in \"DataBindings\" which contains _Binding(s)\n_BINDINGS = 'bindings'\n\n\nclass MetaDataBindings(type):\n    '''\n    Metaclass which prepares a DataBindings class by replacing \"bindings\" (a\n    dict or iterables of 2-tuples) with _Bindings\n    '''\n    def __new__(meta, name, bases, dct, **kwds):\n        # Get the _BINDINGS which must be a dict or tuple of 2-tuples\n        nattrs = dict(dct.pop(_BINDINGS, {}))\n        # replace them with _Binding instances\n        dct.update({name: _Binding(name, val) for name, val in nattrs.items()})\n        # Go over the base classes and do the same\n        battrs = {}\n        _ = [battrs.update(getattr(x, _BINDINGS, {})) for x in bases]\n        battrs.update(nattrs)\n        # update the value in the class dictionary\n        dct[_BINDINGS] = battrs\n        # let the class be created\n        return super().__new__(meta, name, bases, dct, **kwds)\n\n\nclass DataBindings(metaclass=MetaDataBindings):\n    '''\n    Base class for classes holding \"bindings\" (values that one can subscribe to\n    and can be declared)\n\n    During instance creation the declarations in bindings are created in the\n    instance as attributes and as ObservableAttribute (for quick retrieval\n    later)\n    '''\n    def __new__(cls, *args, **kwargs):\n        attrs = getattr(cls, _BINDINGS)  # Get the defined bindings\n        # scan kwargs for values intended to initialize bindings and remove\n        # use default value if not present in kwargs\n        defaults = {k: kwargs.pop(k, v) for k, v in attrs.items()}\n        self = super().__new__(cls, *args, **kwargs)  # create instance\n        for k, v in defaults.items():\n            setattr(self, k, v)  # set attribute\n            # Set ObservableAttribute to avoid dynamic creation\n            setattr(self, '{}_'.format(k), ObservableAttribute(self, k))\n\n        return self\n\n\n# Small alias for DataBindings for classes which simply hold bindings but are\n# not modules or components\nModel = DataBindings\n"], "anpylar.observable_operators": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .observable_base import (ObservableOperator, _MetaObservableOperator,\n                              Disposable, ObservableStopError)\n\nfrom .utils import defaultdict\n\n__all__ = []\n\n\nclass All_Operator(ObservableOperator):\n    '''\n    Check if all items generated by the Observable meet the condition\n    determined by ``predicate``\n    '''\n\n    def __init__(self, predicate):\n        self._fn = predicate\n        self._result = True\n\n    def on_next(self, val, sid):\n        if self._result:\n            self._result = self._fn(val)\n\n    def on_completed(self, sid):\n        self._next(self._result, sid)\n        super().on_completed(sid)\n\n\nclass Catch_Exception_Operator(ObservableOperator):\n    '''\n    Swicth to another observable if an error has been produced and ``on_error``\n    would be invoked in the subscriber.\n\n      - If ``handler`` is an *Observable*, it will be forwarded to it\n\n      - Else, ``handler`` must be a callable accepting the value and returning\n        the value to switch to for forwarding\n\n      - If the forwarded value is an *Observable* it will be the result to\n        switch to\n\n      - Else, the forwarded value will be converted using ``Observable.of``\n    '''\n\n    def __init__(self, handler):\n        self._handler = handler\n        self._isobs = isinstance(handler, Observable)\n        self._active = defaultdict(bool)\n        # End of chain, trigger a fake subscription\n        # self.subscribe(Subscription(self))  # trigger\n\n    def on_error(self, error, sid):\n        # remove signaling that error happened\n        if self._active[sid]:\n            super.on_error(error, sid)\n            return\n\n        self._active[sid] = True\n        self._error_old, self._error = self._error, None\n        if self._isobs:\n            obs = self._handler\n        else:\n            obs = self._handler(error)\n            if not isinstance(obs, Observable):\n                obs = Observable.of(obs)\n\n        # Internal subscription, for notified sid\n        # self._delay_next(sid, lambda: obs._subscribe(self, sid))\n        obs._subscribe(self, sid)\n\n\nclass Debounce_Operator(ObservableOperator):\n    '''\n    Delay the generated value by the amount of milliseconds ``ms`` and discard\n    the delayed value if a new one is produced.\n    '''\n\n    _timed_op = True\n\n    def __init__(self, ms):\n        self.tout = ms\n        self.timers = defaultdict(int)\n\n    def _bouncer(self, val, sid):\n        self.timers[sid] = None\n        self._next(val, sid)\n\n    def on_next(self, val, sid):\n        if self.timers[sid]:\n            self._delay_stop(sid, self.timers[sid])\n\n        self.timers[sid] = \\\n            self._delay_next(sid, lambda: self._bouncer(val, sid), self.tout)\n\n\nclass DefVal_Operator(ObservableOperator):\n    '''\n    This is a particular implementation in *AnPyLar*. It provides a default\n    value for the Observable + Chain of Operators, intended for elements that\n    for example subscribe in the background (like html nodes do)\n\n    It is intended to be used as the last operator in a chain (although with\n    care it can be used earlier in the chain)\n    '''\n\n    def __init__(self, defval):\n        self.defval = defval\n\n    def subscribe(self, *args, **kwargs):\n        disp = super().subscribe(*args, **kwargs)\n        disp.val = self.defval\n        return disp\n\n\nclass Delay_Operator(ObservableOperator):\n    '''\n    Delay the generated value by ``ms`` milliseconds\n    '''\n    _timed_op = True\n\n    def __init__(self, ms):\n        self.tout = ms\n\n    def on_next(self, val, sid):\n        self._delay_next(sid, lambda: self._next(val, sid), self.tout)\n\n\nclass Distinct_Operator(ObservableOperator):\n    '''\n    Let the value through if it has not been seen before. If ``predicate`` is\n    provided it will be used to assess if a value is distinct from previous\n    values\n\n    .. note:: Use with care, because on long running observables, the buffer\n              will grow with no limits.\n    '''\n\n    def __init__(self, predicate=None):\n        self._fn = predicate\n        self._lookup = defaultdict(set)\n\n    def _operate(self, val, sid):\n        fn = self._fn\n        if fn is None:\n            if val in self._lookup[sid]:\n                raise ObservableStopError()\n\n        elif any(fn(v, val) for v in self._lookup[sid]):\n            raise ObservableStopError()\n\n        self._lookup[sid].add(val)  # not found, add and progress\n        return val\n\n\nclass Distinct_Until_Changed_Operator(ObservableOperator):\n    '''\n    Let the value through if it is the same that was last seen. If\n    ``predicate`` is provided it will be used to assess if a value is distinct\n    from previous values\n    '''\n\n    def __init__(self, predicate=None):\n        self._fn = predicate if predicate is not None else lambda x, y: x == y\n        self._last = {}\n\n    def _operate(self, val, sid):\n        if sid in self._last:\n            if self._fn(val, self._last[sid]):\n                raise ObservableStopError()\n\n        self._last[sid] = val  # distinct, store\n        return val\n\n\nclass Do_Action_Operator(ObservableOperator):\n    '''\n    It forwards values after calling ``action`` with the incoming value.\n\n    The value is forwarded as is, regardless of the actions of ``action``\n    '''\n\n    def __init__(self, action):\n        self._action = action\n\n    def _operate(self, val, sid):\n        self._action(val)\n        return val\n\n\nclass Filter_Operator(ObservableOperator):\n    '''\n    Forward the value only if ``predicate`` evaluates the value to ``True``\n    '''\n\n    def __init__(self, predicate):\n        self._fn = predicate\n\n    def _operate(self, val, sid):\n        if self._fn(val):\n            return val\n\n        raise ObservableStopError()  # won't deliver\n\n\nclass First_Operator(ObservableOperator):\n    '''\n    Take only the first value.\n\n    If ``predicate`` is provided, it will be used to determine which is the\n    *first* value.\n    '''\n\n    def __init__(self, predicate=None):\n        self._fn = predicate if predicate is not None else lambda x: True\n\n    def on_next(self, val, sid):\n        if self._fn(val):\n            self._next(val, sid)\n            self.on_completed(sid)\n\n\nclass First_Or_Default_Operator(ObservableOperator):\n    '''\n    Take only the 1st value. If ``predicate`` is provided, it will be invoked\n    with each value and the 1st value will be that for which ``predicate``\n    returns ``True``\n\n    If no *first* value can be delivered, the operator will deliver\n    ``default_value`` on completion.\n    '''\n\n    def __init__(self, predicate=None, default_value=None):\n        self._delivered = False\n        self._fn = predicate if predicate is not None else lambda x: True\n        self._default = default_value\n\n    def on_next(self, val, sid):\n        if self._fn(val):\n            self.on_completed(sid)\n\n    def on_completed(sid):\n        if not self._delivered:\n            self._delivered = True\n            self._next(self._default, sid)\n            super().on_completed(sid)\n\n\nclass Map_Operator(ObservableOperator):\n    '''\n    Apply ``fn`` to the generated values generated, forwarding each result\n    '''\n    def __init__(self, fn):\n        self.fn = fn\n\n    def _operate(self, val, sid):\n        return self.fn(val)\n\n\nclass Nop_Operator(ObservableOperator):\n    '''\n    A no-operation operator. It will simply forward values.\n    '''\n    pass  # forwards all operations\n\n\nclass Publish_Operator(ObservableOperator):\n    '''\n    Freezes an observable source to make it multicast. Several subscriptions\n    can take place without values being forwarded to them.\n\n    It supports the following additional operations:\n\n      - ``auto_connect(count)``\n\n        Unfreeze the observable after ``count`` subscriptions have taken place\n\n      - ``connect()``\n\n        Unfreeze the observable\n    '''\n    _cold = -1\n\n    def __init__(self):\n        self._sid = super()._get_sid()\n\n    def _get_sid(self):\n        return self._sid\n\n    def _substrigger(self, sid):\n        if self._cold <= 0:  # connected (0) or awaiting connect (-1)\n            return Disposable(sid=sid)\n\n        if self._cold == 1:  # last auto-connection\n            disp = super()._substrigger(sid)  # trigger\n        else:\n            disp = Disposable(sid=sid)\n\n        self._cold -= 1\n        return disp\n\n    def auto_connect(self, count):\n        # if 0 were allowed, it wouldn't subscribe later\n        self._cold = max(count, 1)\n        return self\n\n    def connect(self):\n        self._cold = 1  # will be removed in _substrigger\n        self._substrigger(self._sid)\n        return self\n\n    def on_completed(self, sid):\n        self._cold = 1  # wait for 1 subs to re-subscribe\n        super().on_completed(sid)\n\n\nclass Switch_Map_Operator(ObservableOperator):\n    '''\n    Swith to another observable based:\n\n      - If ``handler`` is an *Observable*, it will be switched to it\n\n      - Else, ``handler`` must be a callable accepting the value and returning\n        the value to switch to\n\n        - If the return value is an *Observable* it will be the result to\n          switch to\n\n        - Else, the return value will be converted using ``Observable.of``\n    '''\n\n    def __init__(self, handler):\n        if isinstance(handler, Observable):\n            self._obsgen = lambda x: handler\n        else:\n            self._obsgen = lambda x: handler(x)\n\n        self._sidmap = {}  # new observable to old subs id (sid)\n        self._sidobs = {}  # obs, id for new subs\n        self._obs = None\n\n    def on_next(self, val, sid):\n        if sid in self._sidmap:  # comes from new observer\n            orig_sid = self._sidmap[sid]\n            if orig_sid is None:  # late value, purge\n                self._sidmap.pop(orig_sid)\n            else:\n                self._next(val, orig_sid)\n            return\n\n        # A native sid has arrived\n        if sid in self._sidobs:\n            obs, obs_sid = self._sidobs.pop(sid)\n            obs._unsubscribe(obs_sid)\n            self._sidmap[obs_sid] = None  # mark for purging\n\n        obs = self._obsgen(val)\n        if not isinstance(obs, Observable):\n            obs = Observable.of(obs)\n\n        disp = obs.subscribe(self)\n        obs_sid = disp.sid\n\n        self._sidobs[sid] = obs, obs_sid\n        self._sidmap[obs_sid] = sid\n\n\nclass Take_Operator(ObservableOperator):\n    '''\n    Forward at most ``count`` values before ending the subscription.\n    '''\n\n    # _timed_op = True\n\n    def __init__(self, count):\n        self.to_take = defaultdict(lambda: int(count))\n\n    def on_next(self, val, sid):\n        totake = self.to_take[sid]\n        if totake:\n            self.to_take[sid] = totake - 1\n            # self._delay_next(sid, lambda: self._next(val, sid))\n            self._next(val, sid)\n\n        if totake <= 1:\n            self.to_take[sid] = 0\n            self.on_completed(sid)\n            self._unsubscribe(sid)\n\n\nclass Throw__Operator(ObservableOperator):\n    '''\n    Generate an error ``throw`` as the error value\n\n    .. note:: This is the operator and not the ``throw_`` source.\n    '''\n\n    def __init__(self, throw):\n        self._throw = throw\n\n    def on_next(self, val, sid):\n        self.on_error(self._throw, sid)\n"], "anpylar.observable_promise": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .observable_base import ObservableOperator, _MetaObservableOperator\n\n\nfrom .promise import Promise\n\n\n__all__ = []\n\n\nclass _MetaToPromise(_MetaObservableOperator):\n    def __call__(cls, parent, *args, **kwargs):\n        self = super().__call__(parent, *args, **kwargs)  # create\n\n        self._promise = Promise()\n        self._parent._subscribe(self, self._get_sid())\n        return self._promise\n\n\nclass To_Promise_Operator(ObservableOperator, metaclass=_MetaToPromise):\n    def on_next(self, val, sid):\n        self._promise._resolve(val)\n\n    def on_error(self, error, sid):\n        self._promise._reject(error)\n"], "anpylar.observable_sources": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .observable_base import ObservableSource, _MetaObservableSource\n\nfrom .utils import defaultdict\n\n\n__all__ = []\n\n\nclass From__Source(ObservableSource):\n    '''\n    Generates an observable from ``iterable``, generating as many values as\n    elements are present in ``iterable``\n    '''\n    def __init__(self, iterable):\n        self._iterable = iterable\n\n    def _subscribed(self, sid, **kwargs):\n        for x in self._iterable:\n            self.on_next(x, sid=sid)\n\n        self.on_completed(sid=sid)\n\n\nclass Of_Source(ObservableSource):\n    '''\n    Generates an observable from ``*args``, generating as many values as\n    arguments are provided\n    '''\n    def __init__(self, *args):\n        self._args = args\n\n    def _subscribed(self, sid, **kwargs):\n        for arg in self._args:\n            self.on_next(arg, sid=sid)\n\n        self.on_completed(sid=sid)\n\n\nclass Range_Source(ObservableSource):\n    '''\n    Generates an observable that will issue ``count`` events starting with\n    ``start`` and increasing each iteration by ``step``\n    '''\n    def __init__(self, start, count, step=1):\n        self._start = start\n        self._count = count\n        self._step = step\n\n    def _subscribed(self, sid, **kwargs):\n        for i in range(self._start, self._start + self._count, self._step):\n            self.on_next(i, sid=sid)\n\n        self.on_completed(sid=sid)\n\n\nclass Throw__Source(ObservableSource):\n    '''\n    Create an *Observable* that delivers an error using ``throw``\n\n    .. note:: There is also a ``throw_`` operator. See below.\n    '''\n\n    def __init__(self, throw):\n        self._throw = throw\n\n    def _subscribed(self, sid, **kwargs):\n        self.on_error(self._throw, sid)\n"], "anpylar.localdata": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nimport json\n\n\n__all__ = ['LocalData']\n\n\nclass LocalData:\n\n    def __init__(self, data, index, url):\n        # data is a list of dictionaries\n        # each dict instance represents the object\n        # index is the name of the key which acts as the database index\n        self.index = index\n        self.url = url\n\n        self.idata = {d[index]: d for d in data}\n        self.hidx = max(self.idata.keys())\n\n    def __call__(self, method, url, headers, data):\n        dmethod = getattr(self, method.lower())\n        url = url.lstrip(self.url)  # remove base url\n        return dmethod(url, headers, data)\n\n    def get(self, url, headers, data):\n        if data:  # searching\n            result = []\n            search = data\n            for k, v in search.items():\n                v = v.lower()\n                for d in self.idata.values():\n                    val = d[k]\n                    if v in val.lower():\n                        result.append(d)\n\n            return json.dumps(result)\n\n        if not url:  # return all\n            return json.dumps(list(self.idata.values()))\n\n        # return the id (only thing left in url)\n        return json.dumps(self.idata.get(int(url), {}))\n\n    def post(self, url, headers, data):\n        d = json.loads(data)\n        self.hidx = idx = self.hidx + 1  # inc id\n        d[self.index] = idx\n        self.idata[idx] = d\n        return json.dumps(d)\n\n    def put(self, url, headers, data):\n        key = int(url)\n        d = json.loads(data)\n        self.idata[key].update(**d)\n        return json.dumps(d)\n\n    def delete(self, url, headers, data):\n        key = int(url)\n        del self.idata[key]\n        return json.dumps({})\n"], "anpylar.observable_base": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom . import config as aconfig\nfrom .timer import call_soon, call_delayed, call_cancel\n\nfrom .utils import defaultdict\n\n__all__ = ['Observer', 'Observable', '_MetaObservable', 'Disposable',\n           'ObservableOperator', '_MetaObservableOperator',\n           'ObservableSource', '_MetaObservableSource',\n           'ObservableFetchError', 'ObservableStopError']\n\n\nclass ObservableStopError(Exception):\n    pass\n\n\nclass ObservableFetchError(Exception):\n    def __init__(self, val, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.val = val\n\n\nclass Disposable:\n    def __init__(self, **kwargs):\n        self._parents = []\n\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    def _add_parent(self, parent):\n        self._parents.append(parent)\n\n    def get_val(self):\n        return self.val\n\n    def get_sid(self):\n        return self.sid\n\n    def fetch_val(self):\n        return self.val\n\n\nclass Observer:\n\n    def on_next(self, value):\n        '''Called with each value generated by the Observable'''\n        pass\n\n    def on_completed(self):\n        '''Called when the Observable can no longer produce values'''\n        pass\n\n    def on_error(self, error):\n        '''Called when an error has occurred in the chain'''\n        pass\n\n\nclass Subscription:\n    _timed_op = False\n    _error = None\n\n    def __init__(self, parent, on_next=None, on_completed=None, on_error=None):\n        self._parent = parent\n        self._on_next = on_next\n        self._on_completed = on_completed\n        self._on_error = on_error\n\n    def _suboperate(self, val, sid):\n        return val\n\n    def _operate(self, val, sid):\n        return val\n\n    def on_next(self, val, sid):\n        if not self._error and self._on_next:\n            self._on_next(val)\n\n    def on_completed(self, sid):\n        if not self._error and self._on_completed:\n            self._on_completed()\n\n    def on_error(self, error, sid):\n        self._error = error\n        if self._on_error:\n            self._on_error(error)\n        else:\n            if aconfig.observable.log_error is True:\n                print('on_error:', self, '-', error)\n            elif aconfig.observable.log_error:\n                aconfig.observable.log_error(error)\n\n            if aconfig.observable.raise_error:\n                raise Exception(error)\n\n\nclass _MetaObservable(type):\n    def __call__(cls, parent, *args, **kwargs):\n        self = cls.__new__(cls, *args, **kwargs)  # create\n\n        self._parent = parent\n        self._subscriptions = defaultdict(list)\n        self._in_next = defaultdict(int)\n        self._to_complete = defaultdict(bool)\n        self._to_unsubscribe = defaultdict(bool)\n        self._timers = {}\n\n        self._next = super(cls, self).on_next\n\n        self.__init__(*args, **kwargs)\n        return self\n\n    def __getattr__(cls, name):\n        if not name.startswith('__'):\n            try:\n                return cls._staticmethods[name]\n            except KeyError:\n                pass\n\n        return super().__getattr__(name)\n\n\nclass Observable(object, metaclass=_MetaObservable):\n    _staticmethods = {}\n    _dynamicmethods = {}\n\n    _streamid = 1\n    _error = None\n\n    # indicator than recursive on_next timer would happen with delay_next\n    _timed_op = False\n\n    def __getattr__(self, name):\n        if not name.startswith('__'):\n            try:\n                cls = Observable._dynamicmethods[name]\n                return lambda *a, **kw: cls(self, *a, **kw)\n            except KeyError:\n                pass\n\n        return super().__getattr__(name)\n\n    def _suboperate(self, val, sid):\n        val = self._operate(val, sid)\n        for s in self._subscriptions[sid]:\n            val = s._suboperate(val, sid)\n            break  # do only for the 1st\n\n        return val\n\n    def _operate(self, val, sid):\n        return val\n\n    def _delay_next(self, sid, fn, tout=0):\n        if self._to_complete[sid] or self._to_unsubscribe[sid]:\n            return 0\n\n        def cb():\n            self._in_next[sid] -= 1  # counter the effect of the +1 below\n            fn()\n\n        self._in_next[sid] += 1\n        return call_delayed(tout, cb)\n\n    def _delay_stop(self, sid, t):\n        # cancelling the +1 from above, because cb above wasn't called\n        self._in_next[sid] -= 1\n        call_cancel(t)\n\n    @staticmethod\n    def _get_sid():\n        Observable._streamid = sid = Observable._streamid + 1\n        return sid\n\n    def _substrigger(self, sid, **kwargs):\n        if self._parent is not None:\n            return self._parent._subscribe(self, sid, **kwargs)\n        else:\n            try:\n                self._subscribed(sid, **kwargs)\n            except ObservableFetchError as e:\n                val = self._suboperate(e.val, sid)\n                return Disposable(val=val, sid=sid)\n\n            # no meaningful value can be given in the disposable\n            return Disposable(sid=sid)\n\n    def _subscribe(self, sub, sid, **kwargs):\n        self._subscriptions[sid].append(sub)\n        disp = self._substrigger(sid, **kwargs)\n        disp._add_parent(self)\n        return disp\n\n    def subscribe(self, on_next, on_completed=None, on_error=None,\n                  observer=None, fetch=False, **kwargs):\n\n        if isinstance(on_next, Subscription):\n            sub = on_next\n\n        elif isinstance(on_next, ObservableSource):\n            # The for only using it as on_next is that we are only setting the\n            # value at the source. Else, there could be circular references\n            sub = Subscription(self, on_next)\n\n        elif isinstance(on_next, Observable):\n            sub = on_next\n\n        elif observer is not None:\n            sub = observer\n        else:\n            if not on_completed:\n                on_completed = getattr(on_next, 'on_completed', None)\n            if not on_error:\n                on_error = getattr(on_next, 'on_error', None)\n\n            on_next = getattr(on_next, 'on_next', on_next)\n            sub = Subscription(self, on_next, on_completed, on_error)\n\n        return self._subscribe(sub, sid=self._get_sid(), fetch=fetch, **kwargs)\n\n    def _unsubscribe(self, sid):\n        if sid is None:\n            for sid in self._subscriptions:\n                call_soon(lambda sid=sid: self._unsubscribe(sid))\n            return\n\n        if self._in_next[sid] > 0 or self._to_complete[sid]:\n            self._to_unsubscribe[sid] = True\n            return\n\n        self._to_unsubscribe[sid] = False\n\n        if self._parent is not None:\n            self._parent._unsubscribe(sid)\n\n        # safe pop as it could have completed meanwhile\n        self._subscriptions.pop(sid, None)\n        self._unsubscribed(sid)\n\n    def on_next(self, val, sid=None):\n        if sid is None:  # multicast\n            for sid in self._subscriptions:\n                self._delay_next(sid, lambda s=sid: self._streams_next(val, s))\n\n        elif self._timed_op:  # gone thru delay, don't delay again\n            self._streams_next(val, sid)\n        else:  # yield in case someone needs something\n            self._delay_next(sid, lambda: self._streams_next(val, sid))\n\n    def _streams_next(self, val, sid):\n        # The rationale to catch here the exceptions for on_error is that there\n        # is no need for individual logic in the on_next implementations,\n        # because if an on_next fails, its partner on_error can be hier\n        # directly called to complete the chain.\n        # other subscriptions at this level are not affected, because the\n        self._in_next[sid] += 1\n\n        for s in self._subscriptions[sid]:\n            try:\n                s.on_next(val, sid)\n            except Exception as e:\n                s.on_error(e, sid)\n\n        self._in_next[sid] -= 1\n        if self._to_complete[sid]:\n            call_soon(lambda: self._streams_completed(sid))\n        elif self._to_unsubscribe[sid]:\n            call_soon(lambda: self._unsubscribe(sid))\n\n    def on_completed(self, sid):\n        if not self._error:\n            if not self._timed_op:\n                call_soon(lambda s=sid: self._streams_completed(s))\n            else:\n                self._streams_completed(sid)\n\n    def _streams_completed(self, sid):\n        if sid is None:\n            for sid in self._subscriptions:\n                call_soon(lambda s=sid: self._streams_completed(s))\n            return\n\n        # A completion can arrive before \"next\" has completed, because next may\n        # be waiting on a timer. Mark it. It will be recalled at the end of\n        # streams_next\n        if self._in_next[sid] > 0:\n            self._to_complete[sid] = True\n            return\n\n        self._to_complete[sid] = False\n\n        # if already here, a subclassed on_completed has not generated an\n        # exception and it is safe to pop the subscribtions for the given sid\n        for s in self._subscriptions.pop(sid):\n            try:\n                s.on_completed(sid)\n            except Exception as e:\n                s.on_error(e, sid)\n\n        if self._to_unsubscribe[sid]:\n            call_soon(lambda: self._unsubscribe(sid))\n\n    def on_error(self, error, sid):\n        if aconfig.observable.log_error_early:\n            print('on_error:', self, '-', error)\n\n        self._error = error\n        if sid is None:\n            for sid in self._subscriptions:\n                call_soon(lambda s=sid: self._streams_error(error, s))\n\n        else:\n            call_soon(lambda: self._streams_error(error, sid))\n\n    def _streams_error(self, error, sid):\n        # Errors from above do not come out of band like it may happen with\n        # completion. If an error has happened higher in the hierarchy, on_next\n        # won't have been called or will have generated an exception, there is\n        # no need to wait for it then.\n\n        # if already here, there was an error during on_next or on_completed\n        # and the subscriptions will still be there (see above in\n        # streams_completed)\n        for s in self._subscriptions.pop(sid):\n            try:\n                s.on_error(error, sid)\n            except Exception as e:\n                pass  # cannot recover from error notification\n\n    def _subscribed(self, sid, **kwargs):\n        pass\n\n    def _unsubscribed(self, sid):\n        pass\n\n    def __bool__(self):\n        return ObsOpSingle(self, lambda x: bool(x))\n\n    def __eq__(self, other):\n        return ObsOp(self, lambda x, y: x == y, other)\n\n    def __ne__(self, other):\n        return ObsOp(self, lambda x, y: x != y, other)\n\n    def __gt__(self, other):\n        return ObsOp(self, lambda x, y: x > y, other)\n\n    def __ge__(self, other):\n        return ObsOp(self, lambda x, y: x >= y, other)\n\n    def __lt__(self, other):\n        return ObsOp(self, lambda x, y: x < y, other)\n\n    def __le__(self, other):\n        return ObsOp(self, lambda x, y: x <= y, other)\n\n\nclass _MetaObservableOperator(_MetaObservable):\n    def __init__(cls, name, bases, dct, **kwds):\n        super().__init__(name, bases, dct, **kwds)\n\n        if name.endswith('_Operator'):\n            obsname = name[:-9].lower()\n            Observable._dynamicmethods[obsname] = cls\n\n\nclass ObservableOperator(Observable, metaclass=_MetaObservableOperator):\n\n    def on_next(self, val, sid):\n        try:\n            val = self._operate(val, sid)\n        except ObservableStopError:\n            return\n\n        super().on_next(val, sid)\n\n\nclass ObsOpSingle(ObservableOperator):\n\n    def __init__(self, op):\n        self._op = op\n        self._val = None\n        self._subscribing = False\n\n    def subscribe(self, on_next, on_completed=None, on_error=None,\n                  observer=None, fetch=False, **kwargs):\n\n        self._subscribing = True\n        disp1 = super().subscribe(on_next, on_completed, on_error,\n                                  observer, fetch, **kwargs)\n\n        sid = disp1.sid\n        self._subscribing = False\n\n        if fetch:\n            try:\n                v1 = disp1.val\n            except AttributeError:  # one of the vals is not available\n                pass\n            else:\n                self._val = disp1.val = v1\n\n        return disp1\n\n    def _operate(self, val, sid, ix=0):\n        # during subscription we don't want to operate on the value because the\n        # result will be sent as the \"fetched value\" and at this stage, one\n        # value will still be 'NaN'\n        if self._subscribing:\n            return val\n\n        self._val = val\n        return self._op(val)\n\n\nclass ObsOp(ObservableOperator):\n\n    def __init__(self, op, other):\n        self._op = op\n        self._other = other\n        self._vals = defaultdict(lambda: [float('NaN'), float('NaN')])\n        self._subscribing = False\n\n    def subscribe(self, on_next, on_completed=None, on_error=None,\n                  observer=None, fetch=False, **kwargs):\n\n        self._subscribing = True\n        disp1 = super().subscribe(on_next, on_completed, on_error,\n                                  observer, fetch, **kwargs)\n\n        sid = disp1.sid\n        other = self._other\n        if isinstance(other, Observable):\n            disp2 = other.subscribe(\n                lambda v, s: self._operate(v, sid, ix=1),\n                fetch=fetch, **kwargs)\n\n        else:\n            disp2 = Disposable(val=other)\n\n        self._subscribing = False\n\n        if fetch:\n            try:\n                v1, v2 = disp1.val, disp2.val\n            except AttributeError:  # one of the vals is not available\n                pass\n            else:\n                self._vals[sid] = [v1, v2]\n                disp1.val = self._op(v1, v2)\n\n        return disp1\n\n    def _operate(self, val, sid, ix=0):\n        # during subscription we don't want to operate on the value because the\n        # result will be sent as the \"fetched value\" and at this stage, one\n        # value will still be 'NaN'\n        if self._subscribing:\n            return val\n\n        vals = self._vals[sid]\n        vals[ix] = val\n        return self._op(*vals)\n\n\nclass _MetaObservableSource(_MetaObservable):\n    def __init__(cls, name, bases, dct, **kwds):\n        super().__init__(name, bases, dct, **kwds)\n\n        if name.endswith('_Source'):\n            obsname = name[:-7].lower()\n            Observable._staticmethods[obsname] = (\n                lambda *a, **kw: cls(*a, **kw)\n            )\n\n    def __call__(cls, *args, **kwargs):\n        return super().__call__(None, *args, **kwargs)  # create\n\n\nclass ObservableSource(Observable, metaclass=_MetaObservableSource):\n    pass\n"], "anpylar.observable_attribute": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom .utils import operators\n\nfrom .observable import Observable, ObservableSource, ObservableFetchError\n\n\n__all__ = ['Observable', 'ObservableAttribute', 'ObservablePointed']\n\n\nclass ObservableAttribute(ObservableSource):\n\n    def __init__(self, obj, name, ptd=None):\n        # super().__init__()\n        self._desc = getattr(obj.__class__, name)  # to access _Binding API\n        self._obj = obj  # object to which is pointed\n        self._name = name  # attribute pointed to\n        self._ptd = ptd\n        self._whos = {}\n\n    def _subscribed(self, sid, **kwargs):\n        who = getattr(kwargs.get('who', None), '_elid', None)\n        if who is not None:\n            self._whos[who] = sid\n\n        val = self._desc.subscribe(self._obj, self.on_next,\n                                   ptd=self._ptd, who=sid)\n\n        self.on_next(val, sid)\n\n        if kwargs.get('fetch', False):  # someone wants to pre-fetch\n            raise ObservableFetchError(val)\n\n    def on_next(self, val, sid):\n        super().on_next(val, sid)\n\n    def __getattr__(self, name):\n        if not name.startswith('__'):\n            if name[-1] == '_':  # format is: xxx_\n                op = ObservablePointed(self._obj, self._name, name[:-1])\n                setattr(self, name, op)  # cache it\n                return op\n\n        return super().__getattr__(name)\n\n    def __call__(self, val, who=None):\n        sid = self._whos.get(getattr(who, '_elid', None), None)\n        self._desc.__set__(self._obj, val, who=sid)  # triggers subscriptions\n        return val\n\n\nclass ObservablePointed(ObservableAttribute):\n\n    def __call__(self, val, who=None):\n        sid = self._whos.get(getattr(who, '_elid', None), None)\n\n        ptrobj = self._desc.__get__(self._obj)\n        ptrdesc = getattr(ptrobj.__class__, self._ptd)\n        ptrdesc.__set__(ptrobj, val, who=sid)\n\n        self._desc._notify(self._obj, val, sid, self._ptd)\n\n        return val\n"], "anpylar.config": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\n\n\nclass observable:\n    # log errors if no on_error has been provided\n    log_error = True\n    # raise errors as exception if no on_error has been provided\n    raise_error = False\n    # log as soon as it happens\n    log_error_early = False\n\n\nclass router:\n    # log if waiting for components to render failes\n    log_comprender = True\n\n\nclass module:\n    loading_overlay_id = 'anpylar-loading-overlay'\n"], "anpylar.modbase": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom browser import document, window\nimport browser.ajax\nfrom . import html\n\nfrom . import binding\n\n\nclass _MetaMod(binding.MetaDataBindings):\n    def __new__(meta, name, bases, dct, **kwds):\n        # Scan for services in bases and self and install them\n        srv = {}\n        for b in bases:\n            srv.update(getattr(b, 'services', {}))\n\n        srv.update(dict(dct.pop('services', {})))  # pop/update class services\n        dct['services'] = srv  # install in current dictionay\n\n        return super().__new__(meta, name, bases, dct, **kwds)  # create class\n\n    def __init__(cls, name, bases, dct, **kwds):\n        super().__init__(name, bases, dct, **kwds)\n        # calculate the name for html/css fetching\n        urlname = []\n        lastlower = False\n        for x in name:\n            if x.isupper():\n                if lastlower:\n                    urlname.append('_')\n                urlname.append(x.lower())\n                lastlower = False\n            else:\n                urlname.append(x)\n                lastlower = x.islower()\n\n        cls._urlname = ''.join(urlname)\n\n    def __call__(cls, *args, **kwargs):\n        return super().__call__(*args, **kwargs)\n\n\nclass _ModBase(binding.DataBindings, metaclass=_MetaMod):\n    # This javascript insert allows finding the vfs entry in the brython\n    # structures, which in turn will be used to locate non-python files for\n    # packetized apps\n    _anpylar_vfs_finder = '''\n    ;(function($B){\n        var _b_ = $B.builtins\n\n        $B._anpyl_vfs_finder = function(path, fullname) {\n            vpf = $B.path_importer_cache[path] // no path check\n            // console.log('vpf is:', vpf)\n            vfs = vpf.vfs[fullname]\n            // console.log('vfs is:', vfs)\n            if(vfs !== undefined)\n                return vfs[1]\n\n            return _b_.None\n        }\n    })(__BRYTHON__)\n    '''\n\n    __BRYTHON__.win.eval(_anpylar_vfs_finder)\n\n    @staticmethod\n    def _get_paketized_file(name):\n        parts = name.split('/')\n        bundle_name = '{}.vfs.js/'.format(parts[0])\n        for k in __BRYTHON__.path_importer_cache.to_dict():\n            if not k.endswith(bundle_name):\n                continue\n\n            return __BRYTHON__._anpyl_vfs_finder(k, name)  # found - ret it\n\n        return None\n\n    def _css_transform(self, css):\n        cid_name = self._get_cid_name()\n        if not cid_name:\n            return css\n\n        prefix = '[' + cid_name + ']'\n        transformed = []\n        for l in css.splitlines():\n            ls = l.lstrip()\n            if not ls or ls[0] == '@':\n                transformed.append(l)\n                continue  # skip empty / @xxx / non opening bracket lines\n\n            bracepos = l.find('{')\n            if bracepos == -1:\n                transformed.append(l)\n                continue  # skip empty / @xxx / non opening bracket lines\n\n            lrest = ls[bracepos:]  # brace and anything after it\n            l = ls[:bracepos]  # everything before the brace\n            ltokens = l.rstrip().split()  # split whitespace\n            for i, token in enumerate(ltokens):\n                if token == '>':  # token must not be touched\n                    continue\n\n                if ':' in token:  # : was found, 2 tokens in place\n                    ldots = token.split(':')  # put prefix before :\n                    ltokens[i] = ldots[0] + prefix + ':' + ldots[-1]\n                    continue\n\n                if token[-1] == ',':  # place before comma if present\n                    ltokens[i] = token[:-1] + prefix + ','\n                    continue\n\n                ltokens[i] = token + prefix  # regular case\n\n            if not(ltokens):  # only {  - didn't loop\n                ltokens.append(prefix)\n\n            ltokens.append(lrest)  # restore the brace (and rest if any)\n            transformed.append(' '.join(ltokens))\n\n        return '\\n'.join(transformed)\n\n    def _get_urlcomps(self, flag, extension):\n        # prepare the url\n        modname = self.__class__.__module__\n        urlbase = '/'.join(modname.split('.')[:-1])\n        urlcomps = [urlbase] * bool(urlbase)  # nullify to avoid leading /\n        if flag is True:  # specific check for True not for truthness\n            urlcomps.append(self._urlname + extension)\n        else:  # has to be str\n            urlcomps.append(self.stylepath)\n\n        return '/'.join(urlcomps)\n\n    def _get_cid_name(self):\n        return self.__class__.__name__.lower() + '-' + str(self._cid)\n\n    @staticmethod\n    def _visit_nodes(node):\n        # visiting the nodes generates DOMNode instances using the specific tag\n        # classes for each tagname, which guarantees access to the superchared\n        # tags defined in the html module\n        for elem in node.children:\n            Component._visit_nodes(elem)\n\n    def _insert_style(self, style, cache=True):\n        if not style:\n            return\n\n        txt = self._css_transform(style)\n        with html.render_node(document.head):\n            k = {self._get_cid_name(): ''}\n            with html.style(**k) as this:\n                this <= txt\n\n        self._styled.add(self.__class__)  # mark as delivered\n        if cache and self.cachesheets:\n            self._module.cache_add(self._cachename_style, txt)\n\n    def _stylerer(self, node):\n        # class-wide check (in spite of self)\n        if self.__class__ in self._styled:\n            if self.cachesheets:  # if has to refetch, don't bail out\n                return  # already in the head\n\n        if self.cachesheets:\n            cached_style = self._module.cache_get(self._cachename_style)\n            if cached_style is not None:\n                return self._insert_style(cached_style, cache=False)\n\n        if self.stylesheet:\n            return self._insert_style(self.stylesheet)\n\n        if not self.stylepath:\n            return self._insert_style(self.styler())\n\n        # get the url\n        urlpath = self._get_urlcomps(self.stylepath, '.css')\n\n        # Check paketized versions\n        # vfspath = '/'.join(urlcomps)\n        txt = self._get_paketized_file(urlpath)\n        if txt is not None:\n            return self._insert_style(txt)\n\n        # Fetch via ajax\n        def complete(resp):\n            if resp.status == 200 or resp.status == 0:  # 0 from example\n                self._insert_style(resp.text)\n\n        # The URLs in the browser will be those of the \"routes\" (if defined),\n        # that's why the final url has to be a complete one and not simply a\n        # relative one. Hence the call to the router to get it\n        url = self.router._routecalc('', urlpath)\n\n        a = browser.ajax.ajax()\n        a.bind('complete', complete)\n        url += '?v=' + str(window.Date.new().getTime())\n        a.open('GET', url, True)\n        a.send()\n\n    def styler(self):\n        pass\n"], "anpylar.service": [".py", "###############################################################################\n# Copyright 2018 The AnPyLar Team. All Rights Reserved.\n# Use of this source code is governed by an MIT-style license that\n# can be found in the LICENSE file at http://anpylar.com/mit-license\n###############################################################################\nfrom . import binding\n\n\n__all__ = ['Service']\n\n\nclass _MetaService(binding.MetaDataBindings):\n    def __call__(cls, parent, module, *args, **kwargs):\n        self = cls.__new__(cls, *args, **kwargs)  # create\n        self._parent = parent\n        self._module = module\n        self.__init__(*args, **kwargs)\n        return self\n\n\nclass Service(binding.DataBindings, metaclass=_MetaService):\n    '''\n    A *Service* is, as the name indicates* a provider of services for other\n    components.\n\n    It is declared in the ``services = {name: ServiceClass,}`` directive of\n    *Component* and *Module* classes, to enable functionality like for example\n    an http client, a search service, a logging facility, etc.\n\n    Directives:\n\n      - ``bindings ({})``:\n\n        A dictionary containing the name and default value of attributes for\n        the class which will also automatically add bound ``Observables``\n\n        The observables will have a ``_`` (underscore) character appended.\n\n        Setting the value of the attribute will trigger the observable and\n        therefore any actions/subscriptions associated with it. Example:\n\n            bindings = {'myattr': 'myvalue'}\n\n        will create:\n\n          - An attribute ``myattr`` which defaults to ``myvalue``\n\n          - An observable ``myattr_``\n\n    Attributes:\n\n      - ``_parent``: holds the instance of *Component* or *Module* in which the\n        service was instantiated (**use with care**)\n\n      - ``_module``: holds the instance of *Module* in which the\n        service (somewhere along the hierarchy) is. This will be the same as\n        ``_parent`` if the service is declared in a *Module* (**use with\n        care**)\n\n    Attribute Searching:\n\n      - Subclasses of ``Service`` will access the attributes of\n        ``self._parent`` if the attribute is not found as an instance/class\n        attribute.\n    '''\n\n    def __getattr__(self, name):\n        if name.startswith('__'):\n            return super().__getattr__(name)\n\n        return getattr(self._parent, name)\n"]}

    if(window.__ANPYLAR__ === undefined)
        window.__ANPYLAR__ = {autoload: []}  // ensure global scope

    window.__ANPYLAR__.autoload.push(function($B) {
        // brython removes 1st 2 entries later if stdlib import is true
        // our entry would be removed if placed 1st
        $B.path.splice(2, 0, vfspath)
        $B.imported['_importlib'].VFSAutoPathFinder(vfspath, $vfs)  // autoload
    })
})()
