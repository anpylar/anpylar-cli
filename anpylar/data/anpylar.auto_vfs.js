
;(function() {
    var vfspath = "anpylar.vfs.js"
    var $vfs = {"anpylar.observable": [".py", "\nfrom . observable_base import (Observable,_MetaObservable,Disposable,\nObservableStopError,ObservableFetchError,\nObservableSource,ObservableOperator)\nfrom . import observable_sources\nfrom . import observable_operators\nfrom . import observable_promise\n__all__=['Observable','_MetaObservable','Disposable',\n'ObservableStopError','ObservableFetchError',\n'ObservableSource','ObservableOperator']\n"], "anpylar.module": [".py", "\nfrom browser import document,window\nimport browser. ajax\nfrom . import config as aconfig\nfrom . import binding\nfrom . component import Component\nfrom . import html\nfrom . service import Service\nfrom . import router\nfrom . import stacks\nfrom . modbase import _MetaMod,_ModBase\n__all__=['Module']\ndef logout(*args,**kwargs):\n if 0:\n  print(*args,**kwargs)\nclass _MetaModule(_MetaMod):\n '' \n def __call__(cls,*args,**kwargs):\n  autokwargs={k:v for k,v in kwargs. items()if hasattr(cls,k)}\n  for k in autokwargs:\n   kwargs. pop(k)\n  self=cls. __new__(cls,*args,**kwargs)\n  self. _module=self\n  self. _children=[]\n  child=bool(stacks. modules)\n  if not child:\n   stacks. modules. append(self)\n   self. _parent=None\n  else :\n   self. _parent=stacks. modules[-1]\n  for k,v in autokwargs. items():\n   setattr(self,k,v)\n  if not self. service_ns:\n   service_ns=self\n   self. _service_ns=None\n  else :\n   class Service_PlaceHolder:\n    pass\n   self. _service_ns=service_ns=Service_PlaceHolder()\n   if self. service_ns is True :\n    self. _s=service_ns\n   else :\n    setattr(self,self. service_ns,service_ns)\n  for name,service in self. services. items():\n   if issubclass(service,(Service,)):\n    s=service(self,self)\n   else :\n    s=service()\n    s. _module=self. _module\n    s. _parent=self\n   setattr(service_ns,name,s)\n  self. _caching={}\n  if not child:\n   if self. modules:\n    if not isinstance(self. modules,(list,tuple)):\n     submods=[self. modules]\n    else :\n     submods=self. modules\n    isubmods=[submod()for submod in submods]\n   else :\n    isubmods=[]\n  if not child:\n   self. router=self. router_cls(self,isubmods,self. routes)\n   document. body. _comp=self\n  _cachename=self. cachename\n  if not _cachename:\n   _cachename='{}.{}'. format(self. __class__. __module__,\n   self. __class__. __name__)\n  self. _cachename_style='{}.{}'. format(_cachename,'style')\n  self. _stylerer(document. head)\n  self. render(document. head)\n  self. __init__(*args,**kwargs)\n  if not child:\n   ov_id=aconfig. module. loading_overlay_id\n   ov_style_id=ov_id+'-style'\n   for dom_id in [ov_id,ov_style_id]:\n    try :\n     del document[dom_id]\n    except KeyError:\n     pass\n   Component. _visit_nodes(document. body)\n   comps=self. components\n   try :\n    if issubclass(comps,Component):\n     comps=[comps]\n   except TypeError:\n    pass\n   for comp in comps:\n    if not document. select(comp. selector):\n     t=html. _tagout(comp. selector)\n     t. _comp. _loaded()\n   redir=document. query. getvalue('route')\n   self. router. _routing(redir=redir,recalc=bool(redir))\n  return self\nclass Module(_ModBase,metaclass=_MetaModule):\n '' \n modules=[]\n components=[]\n service_ns=False\n services={}\n routes=[]\n router_cls=router. Router\n cachename=None\n cachesheets=True\n _styled=set()\n stylepath=None\n stylesheet=''\n def render(self,node):\n  pass\n def _get_cid_name(self):\n  return''\n def cache_add(self,name,value):\n  self. _caching[name]=value\n def cache_get(self,name):\n  return self. _caching. get(name,None )\n def __getattr__(self,name):\n  if not name. startswith('__'):\n   if self. _parent is not None :\n    return getattr(self. _parent,name)\n  return super(). __getattr__(name)\n"], "anpylar.version": [".py", "\n__version__='1.1.3'\n__tversion__=tuple(int(x)for x in __version__. split('.'))\n"], "anpylar.timer": [".py", "\nimport browser. timer as timer\n__all__=['call_soon','call_delayed','call_cancel']\ndef call_soon(cb,*args,**kwargs):\n if not args and not kwargs:\n  return timer. set_timeout(cb,0)\n return timer. set_timeout(lambda :cb(*args,**kwargs),0)\ndef call_delayed(tout,cb,*args,**kwargs):\n if not args and not kwargs:\n  return timer. set_timeout(cb,tout)\n return timer. set_timeout(lambda :cb(*args,**kwargs),tout)\ndef call_cancel(t):\n return timer. clear_timeout(t)\n"], "anpylar.component": [".py", "\nfrom browser import document,window\nimport browser. ajax\nfrom . import binding\nfrom . import html\nfrom . observable import Observable\nfrom . promise import Promise\nfrom . service import Service\nfrom . import stacks\nfrom . import utils\nfrom . modbase import _MetaMod,_ModBase\n__all__=['Component','ComponentInline']\n_COMPCOUNT=utils. count(1)\n_CIDCOUNT=utils. count(1)\nclass _MetaComponent(_MetaMod):\n def __init__(cls,name,bases,dct,**kwds):\n  super(). __init__(name,bases,dct,**kwds)\n  cid=str(next(_COMPCOUNT))\n  setattr(cls,'_cid',cid)\n  selector=dct. get('selector',None )\n  if not selector:\n   autosel=[]\n   lastlower=False\n   for x in name:\n    if x. isupper():\n     if lastlower:\n      autosel. append('-')\n     autosel. append(x. lower())\n     lastlower=False\n    else :\n     autosel. append(x)\n     lastlower=x. islower()\n   autosel. append('-')\n   autosel. append(cid)\n   dct['selector']=selector=''. join(autosel)\n   setattr(cls,'selector',selector)\n  html. _customize_tag(selector,dotag=True ,component=cls)\n def __call__(cls,*args,**kwargs):\n  htmlnode=stacks. htmlnodes[-1]\n  if htmlnode. _comp is not None :\n   tag=cls. _tagout(_compargs=args,_compkwargs=kwargs)\n   return tag. _comp\n  autokwargs={k:v for k,v in kwargs. items()if hasattr(cls,k)}\n  for k in autokwargs:\n   kwargs. pop(k)\n  self=cls. __new__(cls,*args,**kwargs)\n  self. _children=[]\n  self. _htmlnode=htmlnode\n  self. _module=stacks. modules[-1]\n  self. _parent=htmlnode. _elparent. _comp\n  parent_module=self. _parent. _module\n  if self. _module !=parent_module:\n   self. _parent=self. _module\n  self. _parent. _children. append(self)\n  for k,v in autokwargs. items():\n   setattr(self,k,v)\n  if not self. service_ns:\n   service_ns=self\n  else :\n   class Service_PlaceHolder:\n    pass\n   service_ns=Service_PlaceHolder()\n   if self. service_ns is True :\n    self. _s=service_ns\n   else :\n    setattr(self,self. service_ns,service_ns)\n  for name,service in self. services. items():\n   if issubclass(service,(Service,)):\n    s=service(self,self. _module)\n   else :\n    s=service()\n    s. _module=self. _module\n    s. _parent=self\n   setattr(service_ns,name,s)\n  _cachename=self. cachename\n  if not _cachename:\n   _cachename='{}.{}'. format(self. __class__. __module__,\n   self. __class__. __name__)\n  self. _cachename_style='{}.{}'. format(_cachename,'style')\n  self. _cachename_html='{}.{}'. format(_cachename,'html')\n  self. __init__(*args,**kwargs)\n  return self\nclass Component(_ModBase,metaclass=_MetaComponent):\n '' \n cacheable=True\n cachesheets=True\n _styled=set()\n cachename=None\n selector=None\n htmlpath=True\n htmlsheet=None\n stylesheet=None\n stylepath=True\n service_ns=False\n services={}\n _parent=None\n _module=None\n _cid=0\n def __getattr__(self,name):\n  if name. startswith('__'):\n   return super(). __getattr__(name)\n  try :\n   return getattr(self. _parent,name)\n  except AttributeError:\n   pass\n  e='{} not found in {} nor in its services or hierarchy'.  format(name,self. __class__. __name__)\n  raise AttributeError(e)\n def __setattr__(self,name,value):\n  if name[-1]=='_':\n   if isinstance(value,Observable):\n    super(). __setattr__(name,value)\n    return\n   name1=name[:-1]\n   if name1 in self. bindings:\n    setattr(self,name1,value)\n    return\n   setattr(self. _parent,name,value)\n   return\n  super(). __setattr__(name,value)\n @classmethod\n def _tagout(cls,*args,**kwargs):\n  return html. _tagout(cls. selector,*args,**kwargs)\n def _loaded(self,dochildren=True ):\n  self. loaded()\n  if dochildren:\n   for child in self. _children:\n    child. _loaded(dochildren=dochildren)\n def loaded(self):\n  pass\n def _load(self,loading=True ,dochildren=True ):\n  self. load(loading=loading)\n  if dochildren:\n   for child in self. _children:\n    child. _load(loading=loading)\n def _renderer(self,node):\n  self. _stylerer(node)\n  with html. render_node(node):\n   promise=self. _htmlerer(node)\n   if promise:\n    stacks. comprender. append(promise)\n def _set_html(self,node,text,cache=True ,render=True ):\n  if text is None :\n   return\n  node. set_html(text)\n  with node:\n   self. _visit_nodes(node)\n  if cache:\n   if self. cachesheets:\n    self. _module. cache_add(self. _cachename_html,text)\n  if render:\n   self. render(node)\n def _htmlerer(self,node):\n  if self. cachesheets:\n   cached_html=self. _module. cache_get(self. _cachename_html)\n   if cached_html is not None :\n    return self. _set_html(node,cached_html,cache=False )\n  if self. htmlsheet:\n   return self. _set_html(node,self. htmlsheet)\n  if not self. htmlpath:\n   return self. _set_html(node,self. render(node),render=False )\n  urlpath=self. _get_urlcomps(self. htmlpath,'.html')\n  txt=self. _get_paketized_file(urlpath)\n  if txt is not None :\n   return self. _set_html(node,txt)\n  promise=Promise()\n  def complete(resp):\n   if resp. status ==200 or resp. status ==0:\n    with html. render_node(node):\n     self. _set_html(node,resp. text)\n    promise. _resolve(True )\n   else :\n    promise. _reject(resp)\n  url=self. router. _routecalc('',urlpath)\n  a=browser. ajax. ajax()\n  a. bind('complete',complete)\n  url +='?v='+str(window. Date. new(). getTime())\n  a. open('GET',url,True )\n  a. send()\n  return promise\n def _can_deactivate(self):\n  ret=self. can_deactivate()\n  if not isinstance(ret,Observable):\n   ret=Observable. of(ret)\n  return ret\n def _binder(self,binder,binding,lambdize=True ):\n  if lambdize:\n   if not binding. startswith('self.'):\n    binding='self.'+binding\n   k={'self':self}\n   exec('_l = lambda: '+binding,k)\n   binder(k['_l'])\n  else :\n   if not binding. startswith('self.'):\n    binding='self.'+binding\n   binder(eval(binding))\n def _fmtter(self,fmtter,*args,**kwargs):\n  selfargs=[]\n  for a in args:\n   if a. startswith('self.'):\n    selfargs. append(eval(a))\n   else :\n    selfargs. append(eval('self.{}'. format(a)))\n  selfkw={}\n  for k,v in kwargs. items():\n   if v. startswith('self.'):\n    selfkw[k]=eval(v)\n   else :\n    selfkw[k]=eval('self.{}'. format(v))\n  fmtter(*selfargs,**selfkw)\n @classmethod\n def selector_render(cls,*args,**kwargs):\n  return cls. _tagout(_compargs=args,_compkwargs=kwargs)\n def load(self,loading=True ):\n  ''  \n  if loading:\n   self. loading()\n  else :\n   self. unloading()\n def loading(self):\n  ''  \n  pass\n def unloading(self):\n  ''  \n  pass\n def styler(self):\n  ''  \n  pass\n def render(self,node):\n  ''  \n  pass\n def can_deactivate(self):\n  ''  \n  return True\n def close_outlet(self):\n  ''  \n  self. _load(loading=False )\n  self. _routlet. clear()\nclass ComponentInline(Component):\n '' \n stylepath=None\n htmlpath=None\n"], "anpylar.router": [".py", "\nfrom browser import document,window\nfrom . import config as aconfig\nfrom . import html as html\nfrom . promise import Promise\nfrom . import stacks\nfrom . utils import defaultdict\n__all__=['Route','Router']\nclass HistoryState:\n def __init__(self,redir,**kwargs):\n  self. redir=redir\n  self. state=list(kwargs. items())\nclass RouteSnapshot(object):\n '' \n def __init__(self,path,abspath,rcomps,module,**kwargs):\n  self. path=path\n  self. abspath=abspath\n  self. route_comps=rcomps\n  self. module=module\n  self. params=kwargs\nclass Route(object):\n '' \n _RIDX=1\n base=None\n path=None\n _rsplit=None\n redirect_to=None\n _redir=None\n path_match=None\n component=None\n params={}\n active=False\n can_activate=None\n outlet=None\n def __str__(self):\n  out=[]\n  out. append('-'*10)\n  out. append('idx:'+str(self. idx))\n  out. append('path:'+self. path)\n  out. append('params:'+str(self. params))\n  out. append('runsplit:'+self. _runsplit)\n  out. append('')\n  return'('+' ; '. join(out)+')'\n def __repr__(self):\n  return self. __str__()\n def __eq__(self,other):\n  return self. idx ==other. idx\n def __hash__(self):\n  return self. idx\n def __init__(self,module,submods,bref,bsplit,**kwargs):\n  self. params={}\n  self. module=module\n  self. children=[]\n  self. idx=self. _RIDX\n  self. __class__. _RIDX +=1\n  self. bref=bref\n  self. bsplit=bsplit\n  for submod in submods:\n   for cr in getattr(submod,'routes',[]):\n    r=Route(submod,[],'',[],**cr)\n    self. children. append(r)\n  for k,v in kwargs. items():\n   if k in ['load_children','children']:\n    continue\n   setattr(self,k,v)\n  if self. can_activate:\n   self. can_activate=self. can_activate()\n  for cr in kwargs. get('children',[]):\n   self. children. append(Route(module,[],'',[],**cr))\n  for lchild in kwargs. get('load_children',[]):\n   childmod=lchild()\n   for cr in getattr(lchild,'routes',[]):\n    r=Route(childmod,[],'',[],**cr)\n    self. children. append(r)\n  self. _rsplit=bsplit+self. path. split('/')\n  if not self. _rsplit[-1]:\n   self. _rsplit. pop(-1)\n  self. _runsplit='/'. join(self. _rsplit)\n  if self. redirect_to:\n   if self. redirect_to[0]!='/':\n    self. _redirsplit=bsplit+self. redirect_to. split('/')\n   else :\n    self. _redirsplit=self. redirect_to. split('/')\n   if not self. _redirsplit[-1]:\n    self. _redirsplit. pop(-1)\n   self. _redir='/'. join(self. _redirsplit)\n def match(self,url,**kwargs):\n  if self. path in ['*','**']:\n   return [self]\n  if not url. startswith(self. _runsplit):\n   return []\n  rem_url=url[len(self. _runsplit):]\n  if rem_url and rem_url[0]=='/':\n   rem_url=rem_url[1:]\n  for child in self. children:\n   ret=child. match(rem_url,**kwargs)\n   if ret:\n    return [self]+ret\n  for p in self. params or {}:\n   if p not in kwargs:\n    return []\n  if self. path_match and rem_url:\n   return []\n  return [self]\nclass Router(object):\n '' \n autorouter=True\n selector='router-outlet'\n _routedivs={}\n _rreg=defaultdict(list)\n def __init__(self,module,submods,routes):\n  self. module=module\n  pymodpath=getattr(__BRYTHON__,'$py_module_path')\n  pathname=pymodpath. __main__\n  self. _about=pathname =='about:blank'\n  if self. _about:\n   self. _history=[]\n   self. _histidx=-1\n  if pathname is not None :\n   _psplit=pathname. split('//',1)\n   if len(_psplit)>1:\n    urlsplit=_psplit[1]\n   else :\n    urlsplit='/'\n   psplit=urlsplit. split('/')[1:-1]\n  else :\n   psplit=[]\n  psplit. insert(0,'')\n  self. _basehref=self. basehref=bhref='/'. join(psplit)\n  self. _basesplit=psplit\n  self. routes=rt=[]\n  for submod in submods:\n   for cr in getattr(submod,'routes',[]):\n    r=Route(submod,[],bhref,psplit,**cr)\n    rt. append(r)\n  notfound=None\n  for r in routes:\n   if r. get('path','')in ['*','**']:\n    notfound=Route(module,[],bhref,psplit,**r)\n   rt. append(Route(module,[],bhref,psplit,**r))\n  if notfound:\n   rt. append(notfound)\n  self. _ractive=None\n  self. _ractives=[]\n  window. onpopstate=self. _onpopstate\n def _onpopstate(self,evt):\n  kwargs={}\n  if evt. state:\n   kwargs. update({x:y for x,y in evt. state})\n  redir=evt. redir if self. _about else None\n  self. _routing(popstate=True ,redir=redir,params=((),kwargs))\n def _routeregister(self,pathname,cb,*args,**kwargs):\n  self. _rreg[pathname]. append((cb,args,kwargs))\n def _routecalc(self,*args):\n  tail='/'. join(args)\n  if tail and tail[0]=='/':\n   return'/'. join((self. _basehref,tail[1:]))\n  if tail:\n   if self. _ractive:\n    return'/'. join((self. _ractive,tail))\n   return tail\n  return self. _ractive\n def _route_to(self,cango,pathname,_recalc=True ,*args,**kwargs):\n  if not cango:\n   return\n  if _recalc:\n   route=self. _routecalc(pathname)\n  else :\n   route=pathname\n  pparts=route. split('/')\n  skip=False\n  fpparts=[]\n  for p in reversed(pparts):\n   if p =='..':\n    skip=True\n   elif skip:\n    skip=False\n   elif p !='.':\n    fpparts. append(p)\n  route='/'. join(reversed(fpparts))\n  self. _routing(redir=route,params=(args,kwargs))\n def _routing(self,popstate=False ,redir=None ,recalc=False ,params=()):\n  if stacks. comprender:\n   def reroute(val):\n    self. _routing(popstate=popstate,redir=redir,\n    recalc=recalc,params=params)\n   comprender=stacks. comprender[:]\n   stacks. comprender. clear()\n   p=Promise. all(*comprender). then(reroute)\n   if aconfig. router. log_comprender:\n    p. catch(\n    lambda x:print(\n    'Router: Waiting for component rendering failed:',x\n    )\n    )\n   return\n  if not redir:\n   if not self. _about:\n    pathname=document. location. pathname\n   else :\n    pathname='/'\n   psplit=pathname. split('/')\n   if pathname[-1]=='/':\n    psplit. pop(-1)\n   elif pathname. endswith('.html'):\n    psplit. pop(-1)\n   punsplit='/'. join(psplit)\n  else :\n   if recalc:\n    redir=self. _routecalc(redir)\n   punsplit=redir\n  punpath=punsplit[len(self. _basehref):]\n  if params:\n   args,kwargs=params\n  else :\n   args=()\n   kwargs={}\n  if';'in punsplit:\n   lcolons=punsplit. split(';')\n   punsplit=lcolons[0]\n   for colon in lcolons[1:]:\n    name,value=colon. split('=')\n    kwargs[name]=value\n  for r in self. routes:\n   route_path=r. match(punsplit,**kwargs)\n   if not route_path:\n    continue\n   r0=route_path[0]\n   outlet=r0. outlet\n   if not outlet:\n    comp,rout=None ,None\n    while self. _ractives:\n     r=self. _ractives. pop()\n     if r in route_path:\n      self. _ractives. append(r)\n      break\n     r. active=False\n     newcomp,newrout=self. _routedivs. get(r. idx,(None ,None ))\n     if newcomp:\n      comp,rout=newcomp,newrout\n    if comp is not None :\n     comp. _load(loading=False )\n     rout. parentNode. clear()\n    next_r=route_path[-1]\n    pstate=punsplit\n    if kwargs:\n     paramstate=';'. join(\n     ('='. join((str(k),str(v)))for k,v in kwargs. items()\n     if k in next_r. params)\n     )\n     if paramstate:\n      pstate +=';'+paramstate\n    if not popstate and not next_r. redirect_to:\n     if not self. _about:\n      if kwargs:\n       lkwargs=list(kwargs. items())\n       window. history. pushState(lkwargs,'',pstate)\n      else :\n       window. history. pushState('','',pstate)\n     else :\n      if self. _history:\n       lastpstate=self. _history[-1]. redir\n      else :\n       lastpstate=''\n      if lastpstate !=pstate:\n       hstate=HistoryState(pstate,**kwargs)\n       self. _history. insert(self. _histidx+1,hstate)\n       self. _histidx +=1\n    r=next_r\n    if r. params:\n     for name,transform in r. params. items():\n      if name in kwargs:\n       kwargs[name]=transform(kwargs[name])\n    active_route=RouteSnapshot(punpath,punsplit,\n    route_path,r. module,**kwargs)\n    self. module. route=self. module. r=self. route=active_route\n    self. module. params=self. module. p=active_route. params\n    if len(route_path)==len(self. _ractives):\n     route=route_path[-1]\n     if route. idx in self. _routedivs:\n      comp,rdiv=self. _routedivs[route. idx]\n      if comp is not None :\n       comp. _load(dochildren=False )\n     return\n    lastroute=route_path[-1]\n    if lastroute. redirect_to:\n     self. _routing(redir=lastroute. _redir,recalc=True ,\n     params=params)\n     return\n    node=document\n    for route in route_path[1:len(self. _ractives)]:\n     if route. idx in self. _routedivs:\n      _,node=self. _routedivs[route. idx]\n    if self. _ractive in self. _rreg:\n     rreg=self. _rreg[self. _ractive]\n     for cb,a,kw in self. _rreg[self. _ractive]:\n      cb(False ,*a,**kw)\n    self. _ractive=punsplit\n    if punsplit in self. _rreg:\n     for cb,a,kw in self. _rreg[punsplit]:\n      cb(True ,*a,**kw)\n    rpath=route_path[len(self. _ractives):]\n   else :\n    node=document. body\n    rpath=route_path\n   isoutlet=bool(outlet)\n   for route in rpath:\n    if route. can_activate:\n     if not route. can_activate. can_activate(active_route):\n      return\n    outlet=route. outlet\n    if not isoutlet:\n     self. _ractives. append(route)\n    selector=self. selector\n    if outlet:\n     selector +='[name=\"{}\"]'. format(outlet)\n    routlet=node. select_one(selector)\n    if not routlet:\n     if not self. autorouter:\n      return\n     if not outlet:\n      routlet=html. _routeout(self. selector)\n     else :\n      routlet=html. _routeout(self. selector,name=outlet)\n    rdiv=None\n    if route. idx in self. _routedivs:\n     comp,rdiv=self. _routedivs[route. idx]\n     if comp is not None :\n      comp. _load(dochildren=False )\n      routlet. _comp. _children=[rdiv. _comp]\n      routlet <=rdiv\n      comp. _loaded()\n    else :\n     stacks. modules. append(route. module)\n     if route. component is not None :\n      with html. render_node(routlet):\n       rdiv=html. _routeout(route. component. selector)\n      comp=rdiv. _comp\n      routlet. _comp. _children=[comp]\n      comp. _routlet=routlet\n      comp. _rdiv=rdiv\n      comp. _load(dochildren=False )\n      if comp. cacheable:\n       self. _routedivs[route. idx]=(comp,rdiv)\n     stacks. modules. pop()\n    if rdiv:\n     node=rdiv\n   return\n def route_to(self,pathname,*args,**kwargs):\n  ''  \n  _recalc=kwargs. pop('_recalc',True )\n  ractive=self. _ractives[-1]if self. _ractives else None\n  if ractive:\n   comp,rout=self. _routedivs. get(ractive. idx,(None ,None ))\n   if comp:\n    ret=comp. _can_deactivate()\n    ret. subscribe(\n    lambda x:self. _route_to(\n    x,pathname,_recalc=_recalc,*args,**kwargs\n    )\n    )\n    return\n  self. _route_to(True ,pathname,*args,**kwargs)\n def back(self):\n  if self. _about:\n   hidx=self. _histidx -1\n   if hidx >=0:\n    self. _histidx -=1\n    self. _onpopstate(self. _history[hidx])\n  else :\n   window. history. back()\n def forward(self):\n  if self. _about:\n   hidx=self. _histidx+1\n   if hidx <len(self. _history):\n    self. _histidx +=1\n    self. _onpopstate(self. _history[hidx])\n  else :\n   window. history. forward()\n"], "anpylar.stacks": [".py", "\nimport browser\n__all__=[]\n_stacks={}\ndef get(name,default=[]):\n if name in _stacks:\n  return _stacks[name]\n _stacks[name]=sname=list(default)\n return sname\nmodules=get('modules')\nhtmlnodes=get('html',[browser. document. body])\ncomprender=get('comprender')\n"], "anpylar.utils": [".py", "\n__all__=['empty','deque','defaultdict','itercount','operators']\ndef logout(*args,**kwargs):\n print(*args,**kwargs)\nclass empty(object):\n def __init__(self,*args,**kwargs):\n  for name,value in kwargs. items():\n   setattr(self,name,value)\n pass\nclass defaultdict(dict):\n def __init__(self,default):\n  super(). __init__()\n  self. _default=default\n def __missing__(self,key):\n  self[key]=r=self. _default()\n  return r\nclass deque(list):\n def __init__(self,iterable=None ,maxlen=0):\n  self. _maxlen=maxlen\n  if iterable is not None :\n   if len(iterable)>maxlen:\n    iterable=iterable[:maxlen]\n   args=[iterable]\n  else :\n   args=[]\n  super(). __init__(*args)\n def append(self,item):\n  if self. _maxlen and len(self)==self. _maxlen:\n   self. pop(0)\n  super(). append(item)\n def appendleft(self,item):\n  if self. _maxlen and len(self)==self. _maxlen:\n   self. pop()\n  self. insert(0,item)\n def popleft(self):\n  return self. pop(0)\nclass operators:\n eq=staticmethod(lambda x,y:x ==y)\n gt=staticmethod(lambda x,y:x >y)\n ge=staticmethod(lambda x,y:x >=y)\n lt=staticmethod(lambda x,y:x <y)\n le=staticmethod(lambda x,y:x <=y)\ndef itercount(start=0,step=1):\n while True :\n  yield start\n  start +=step\nclass count:\n def __init__(self,start=0,step=1):\n  self. start=start -1\n  self. step=1\n def __iter__(self):\n  return self\n def __next__(self):\n  self. start +=self. step\n  return self. start\n"], "anpylar.promise": [".py", "\nfrom . future import Future,CatchError\nfrom . timer import call_delayed\n__all__=['Promise','Future']\nclass Promise(Future):\n '' \n def __init__(self,executor=None ,reject=None ):\n  ''  \n  super(). __init__()\n  if executor:\n   try :\n    if reject is None :\n     executor(self. _resolve,self. _reject)\n    else :\n     executor(self. _resolve)\n     reject(self. _reject)\n   except Exception as e:\n    self. set_exception(e)\n def _resolve(self,result,timeout=None ):\n  if isinstance(result,Future):\n   self. _chain(result,timeout)\n  elif timeout:\n   call_delayed(timeout,lambda :self. set_result(result))\n  else :\n   self. set_result(result)\n  return self\n def _reject(self,exception,timeout=None ):\n  if isinstance(exception,Future):\n   return self. _chain(exception,timeout)\n  elif timeout:\n   call_delayed(timeout,lambda :self. set_exception(exception))\n  else :\n   self. set_exception(exception)\n  return self\n @staticmethod\n def resolve(value):\n  ''  \n  return Promise(lambda resolve,reject:resolve(value))\n @staticmethod\n def reject(value):\n  ''  \n  return Promise(lambda resolve,reject:reject(value))\n @staticmethod\n def all(*promises):\n  ''  \n  if not promises:\n   return Promise. resolve([])\n  count=[None ]*len(promises)\n  results=count[:]\n  retpromise=Promise()\n  def thener(result,i):\n   results[i]=result\n   count. pop()\n   if not count:\n    retpromise. _resolve(results)\n  def catcher(error):\n   retpromise. _reject(error)\n  for i,promise in enumerate(promises):\n   if isinstance(promise,Promise):\n    promise    . then(lambda x,i=i:thener(x,i))    . catch(catcher)\n   else :\n    count. pop()\n    results[i]=promise\n  if not count:\n   return Promise. resolve(results)\n  return retpromise\n @staticmethod\n def race(*promises):\n  ''  \n  retpromise=Promise()\n  def thener(result):\n   if not retpromise. done():\n    retpromise. _resolve(result)\n  def catcher(error):\n   if not retpromise. done():\n    retpromise. _reject(error)\n  to_wait=[]\n  for promise in promises:\n   if isinstance(promise,Promise):\n    if promise. cancelled():\n     continue\n    if promise. done():\n     try :\n      result=promise. result()\n     except CatchError:\n      retpromise. _reject(promise. exception())\n     else :\n      retpromise. _resolve(result)\n     to_wait=[]\n     break\n    to_wait. append(promise)\n   else :\n    retpromise. _resolve(promise)\n    to_wait=[]\n    break\n  for promise in to_wait:\n   promise. then(thener). catch(catcher)\n  return retpromise\n def then(self,then,catch=None ):\n  ''  \n  promise=Promise()\n  def done_callback(fut):\n   if fut. cancelled():\n    self. cancel()\n    return\n   try :\n    result=fut. result()\n    if then:\n     result=then(result)\n    if isinstance(result,Future):\n     promise. _chain(result)\n    else :\n     promise. set_result(result)\n   except (CatchError,Exception)as result:\n    if isinstance(result,CatchError):\n     result=result. args[0]\n    if catch:\n     try :\n      result=catch(result)\n     except Exception as result:\n      pass\n     if not isinstance(result,Exception):\n      promise. set_result(result)\n     else :\n      promise. set_exception(result)\n    else :\n     promise. set_exception(result)\n  self. add_done_callback(done_callback)\n  return promise\n def catch(self,catch):\n  ''  \n  return self. then(None ,catch)\n def _chain(self,promise,timeout=None ):\n  def done_callback(fut):\n   if fut. cancelled():\n    self. cancel()\n    return\n   try :\n    result=fut. result()\n    if isinstance(result,Future):\n     self. _chain(result,timeout)\n    elif timeout is not None :\n     call_delayed(timeout,lambda :self. set_result(result))\n    else :\n     self. set_result(result)\n   except Exception as e:\n    if timeout is not None :\n     call_delayed(timeout,lambda :self. set_exception(e))\n    else :\n     self. set_exception(e)\n  promise. add_done_callback(done_callback)\n"], "anpylar.tweaks": [".py", "\nB=__BRYTHON__\nB. DOMNodeDict. select_all=B. DOMNodeDict. select\nB. DOMNodeDict. select=B. DOMNodeDict. select_one\n"], "anpylar.http": [".py", "\nfrom browser import ajax\nfrom . observable import ObservableSource\nfrom . localdata import LocalData\n__all__=['Http','HttpException']\nclass HttpException(Exception):\n '' \n def __init__(self,request):\n  super(). __init__(request)\n  self. req=request\nclass HttpRequest(ObservableSource):\n '' \n def __init__(self,caller,method,url,headers=None ,data=None ,\n fullresp=False ):\n  self. _method=method\n  self. _url=url\n  self. _headers=headers\n  self. _data=data\n  self. _sid=None\n  self. _fullresp=fullresp\n def _subscribed(self,sid,**kwargs):\n  self. _sid=sid\n  self. _req=req=ajax. ajax()\n  req. bind('complete',lambda r:self. _complete_handler(r,sid))\n  req. open(self. _method,self. _url,True )\n  if self. _headers:\n   for k,v in self. _headers. items():\n    req. set_header(k,v)\n  if self. _data:\n   req. send(self. _data)\n  else :\n   req. send()\n def cancel(self):\n  self. _req. abort()\n  self. on_error(False ,self. _sid)\n def _complete_handler(self,resp,sid):\n  ret=resp if self. _fullresp else resp. text\n  if 200 <=resp. status <300:\n   self. on_next(ret,sid)\n  else :\n   self. on_error(ret,sid)\nclass HttpRequestLocalData(ObservableSource):\n '' \n def __init__(self,caller,method,url,headers=None ,data=None ,\n fullresp=False ):\n  self. _caller=caller\n  self. _method=method\n  self. _url=url\n  self. _data=data\n  self. _headers=headers\n  self. _fullresp=fullresp\n def _subscribed(self,sid,**kwargs):\n  ldata=self. _caller. _ldata\n  if ldata is None :\n   for k,v in self. _caller. _LocalData. items():\n    if self. _url. startswith(k):\n     self. _caller. _ldata=ldata=v\n     break\n   if ldata is None :\n    self. on_error(\n    HttpException('No data for path: {}'. format(self. _url))\n    )\n    return\n  response=ldata(self. _method,self. _url,self. _headers,self. _data)\n  self. on_next(response,sid)\nclass Http:\n _RequestClass=HttpRequest\n _LocalData={}\n @classmethod\n def serve(cls,data,index,url='',datacls=LocalData):\n  cls. _LocalData[url]=datacls(data,index,url)\n  cls. _RequestClass=HttpRequestLocalData\n _ldata=None\n def __init__(self,url='',headers=None ,fullresp=False ):\n  self. _fullresp=fullresp\n  self. url=url\n  if headers:\n   self. headers={k. lower():v for k,v in headers. items()}\n  else :\n   self. headers={}\n def _send(self,method,url,headers,data,fullresp=False ):\n  if self. url:\n   if url:\n    url='/'. join((self. url,url))\n   else :\n    url=self. url\n  if method =='GET'and data is not None :\n   q=('='. join((str(k),str(v)))for k,v in data. items())\n   qs='&'. join(q)\n   url +='?'+qs\n  if headers:\n   h=self. headers. copy()\n   h. update({k. lower():v for k,v in headers. items()})\n  else :\n   h=self. headers\n  return self. _RequestClass(self,method,url,h,data,\n  fullresp=self. _fullresp)\n def get(self,url='',headers=None ,data=None ):\n  return self. _send('GET',url,headers,data)\n def post(self,url='',headers=None ,data=None ):\n  return self. _send('POST',url,headers,data)\n def put(self,url='',headers=None ,data=None ):\n  return self. _send('PUT',url,headers,data)\n def delete(self,url='',headers=None ,data=None ):\n  return self. _send('DELETE',url,headers,data)\n"], "anpylar": [".py", "\nfrom . import tweaks\nfrom . import config\nfrom . import authguard\nfrom . import binding\nfrom . import component\nfrom . import html\nfrom . import html as ht\nfrom . import http\nfrom . import localdata\nfrom . import module\nfrom . import service\nfrom . import observable\nfrom . import promise\nfrom . import timer\nfrom . authguard import *\nfrom . binding import *\nfrom . component import *\nfrom . http import *\nfrom . localdata import *\nfrom . module import *\nfrom . observable import *\nfrom . service import *\nfrom . promise import *\nfrom . timer import *\n", 1], "anpylar.authguard": [".py", "\nfrom . import stacks\n__all__=['AuthGuard']\nclass _MetaAuthGuard(type):\n def __new__(meta,name,bases,dct,**kwds):\n  srv={}\n  for b in bases:\n   srv. update(getattr(b,'services',{}))\n  srv. update(dict(dct. pop('services',{})))\n  dct['services']=srv\n  return super(). __new__(meta,name,bases,dct,**kwds)\n def __call__(cls,*args,**kwargs):\n  autokwargs={k:v for k,v in kwargs. items()if hasattr(cls,k)}\n  for k in autokwargs:\n   kwargs. pop(k)\n  self=cls. __new__(cls,*args,**kwargs)\n  self. _module=stacks. modules[-1]\n  for k,v in autokwargs. items():\n   setattr(self,k,v)\n  for name,service in self. services. items():\n   setattr(self,name,service())\n  self. __init__(*args,**kwargs)\n  return self\nclass AuthGuard(metaclass=_MetaAuthGuard):\n services={}\n def __getattr__(self,name):\n  if not name. startswith('__'):\n   if self. _module is not None :\n    return getattr(self. _module,name)\n  return super(). __getattr__(name)\n"], "anpylar.html": [".py", "\nimport browser\nimport browser. html\nfrom . import stacks\nfrom . utils import defaultdict,count\nfrom . import utils\nfrom . observable import Observable\n__all__=[]\nclass render_node(object):\n def __init__(self,node=None ):\n  self. node=node\n def __enter__(self):\n  node=self. node or stacks. htmlnodes[-1]\n  stacks. htmlnodes. append(node)\n  return node\n def __exit__(self,type_,value,tb):\n  if type_ is None :\n   stacks. htmlnodes. pop(-1)\n   while _el2render:\n    _el2render. pop(-1). _procfuncs()\nclass _MetaElement(type):\n def __call__(cls,*args,**kwargs):\n  rlink=kwargs. pop('routerlink',None )\n  compargs=kwargs. pop('_compargs',())\n  compkwargs=kwargs. pop('_compkwargs',{})\n  self=super(). __call__(*args,**kwargs)\n  taglower=getattr(self,'tagName',''). lower()\n  if taglower not in ['script','head','style']:\n   _el2render. append(self)\n  if not hasattr(self,'_elparent'):\n   self. _started=False\n   self. _elid=next(_ELID)\n   self. _elparent=stacks. htmlnodes[-1]\n   self. _rlink=rlink\n   self. _funcs=defaultdict(list)\n   self. _dfuncs=defaultdict(list)\n   self. _sargs=defaultdict(list)\n   self. _kargs=defaultdict(dict)\n   self. _txtmplate=None\n   self. _cvals=dict()\n  if self. _comp is None :\n   if cls. _autocomp is None :\n    if taglower !='style':\n     try :\n      self. _comp=_comp=self. _elparent. _comp\n     except AttributeError:\n      self. _comp=None\n    if taglower !='router-outlet':\n     try :\n      self. setAttribute(self. _comp. _get_cid_name(),'')\n     except :\n      pass\n   else :\n    with self:\n     self. _comp=cls. _autocomp(*compargs,**compkwargs)\n    self. _comp. _renderer(self)\n    if self. _wrapped:\n     self. _comp. _load()\n   fmtargs=[]\n   fmtkwargs={}\n   for attr in self. attributes:\n    name=attr. name\n    value=attr. value\n    n0=name[0]\n    if n0 =='(':\n     binder=getattr(self. _bindx,name[1:-1])\n     lambdize=value[-1]==')'\n     self. _comp. _binder(binder,value,lambdize=lambdize)\n    elif n0 =='*':\n     binder=getattr(self,name[1:])\n     self. _comp. _binder(binder,value,lambdize=False )\n    elif n0 =='[':\n     name=name[1:-1]\n     if not name:\n      name=value\n     fmtargs. append(name)\n    elif n0 =='{':\n     fmtkwargs[name[1:-1]]=value\n    elif n0 =='$':\n     binder=getattr(self. _bind,name[1:-1])\n     lambdize=value[-1]==')'\n     self. _comp. _binder(binder,value,lambdize=lambdize)\n   if fmtargs or fmtkwargs:\n    self. _comp. _fmtter(self. _fmt,*fmtargs,**fmtkwargs)\n  if not self. _wrapped:\n   if taglower !='txt':\n    if self. _elparent. children:\n     self. _elparent <='\\n'\n   self. _elparent <=self\n  if hasattr(self,'do_customize'):\n   do_customize=getattr(self,'do_customize')\n   if do_customize !=self:\n    self. do_customize(*args,**kwargs)\n  return self\nclass SuperchargedNode(object,metaclass=_MetaElement):\n '' \n _comp=None\n _autocomp=None\n _TXT='text'\n def __enter__(self):\n  stacks. htmlnodes. append(self)\n  return self\n def __exit__(self,type_,value,traceback):\n  stacks. htmlnodes. pop(-1)\n def _ractive(self,status,ractive):\n  cl=self. class_name. split()\n  if status:\n   if ractive not in cl:\n    cl. append(ractive)\n  else :\n   if ractive in cl:\n    cl. remove(ractive)\n  self. class_name=' '. join(cl)\n def _procfuncs(self):\n  self. _started=True\n  rlink=self. _rlink\n  if rlink is None :\n   self. _rlink=rlink=getattr(self,'routerlink',None )\n  if rlink is not None :\n   router=self. _comp. router\n   if isinstance(rlink,str):\n    rl=rlink\n    ret=router. _routecalc(rl)\n    self. bind(\n    'click',\n    lambda x:router. route_to(ret,_recalc=False )\n    )\n   else :\n    rl,kw=rlink\n    ret=router. _routecalc(rl)\n    self. bind(\n    'click',\n    lambda x:router. route_to(ret,_recalc=False ,**kw)\n    )\n   ractive=getattr(self,'routerlinkactive',None )\n   if ractive:\n    router. _routeregister(ret,self. _ractive,ractive)\n  if self. _txtmplate is None :\n   self. _txtmplate=getattr(self,self. _TXT)\n  if not self. _txtmplate:\n   self. _txtmplate='{}'\n  with render_node(self):\n   for k,fl in self. _funcs. items():\n    for func in fl:\n     func(*self. _sargs[k],**self. _kargs[k])\n def __call__(self,val,key,ref):\n  sargs=self. _sargs[key]\n  kargs=self. _kargs[key]\n  if isinstance(ref,int):\n   sargs[ref]=val\n  else :\n   kargs[ref]=val\n  if not self. _started:\n   return\n  if key in self. _funcs:\n   fs=self. _funcs[key]\n  else :\n   fs=self. _dfuncs[key]\n  with render_node(self):\n   for f in fs:\n    f(*sargs,**kargs)\n def _subintern(self,func,fargs,fkwargs,delay=False ):\n  key=next(_KEY)\n  if not delay:\n   self. _funcs[key]. append(func)\n  else :\n   self. _dfuncs[key]. append(func)\n  sargs=self. _sargs[key]\n  for i,sarg in enumerate(fargs,len(sargs)):\n   if isinstance(sarg,Observable):\n    kw={'who':self,'fetch':True }\n    v=sarg. subscribe(lambda x,ref=i:self(x,key,ref),**kw)\n    try :\n     v=v. get_val()\n    except AttributeError:\n     v=''\n    sargs. append(v)\n   else :\n    sargs. append(sarg)\n  kargs=self. _kargs[key]\n  for name,karg in fkwargs. items():\n   if isinstance(karg,Observable):\n    kw={'who':self,'fetch':True }\n    v=karg. subscribe(lambda x,ref=name:self(x,key,ref),**kw)\n    try :\n     v=v. get_val()\n    except AttributeError:\n     v=''\n    kargs[name]=v\n   else :\n    kargs[name]=karg\n  return self\n def _sub(self,func,*args,**kwargs):\n  return self. _subintern(func,args,kwargs,delay=False )\n def _subdelay(self,func,*args,**kwargs):\n  return self. _subintern(func,args,kwargs,delay=True )\n def _fmtrecv(self,*args,**kwargs):\n  setattr(self,self. _TXT,self. _txtmplate. format(*args,**kwargs))\n def _fmt(self,*args,**kwargs):\n  ''  \n  return self. _sub(self. _fmtrecv,*args,**kwargs)\n def _fmtfunc(self,func,*args,**kwargs):\n  return self. _sub(\n  lambda *a,**kw:self. _fmtrecv(func(*a,**kw)),\n  *args,**kwargs\n  )\n @property\n def _render(self):\n  ''  \n  return _RenderHelper(self)\n def _pub(self,event,*args,**kwargs):\n  self. bind(event,lambda evt:self. _pubsend(*args,**kwargs))\n  return self\n def _pubattr(self,event,attr,*args,**kwargs):\n  self. bind(event,lambda evt:self. _pubsendattr(attr,*args,**kwargs))\n  return self\n def _pubsub(self,event,func,*args,**kwargs):\n  self. _sub(func,*args,**kwargs)\n  return self. _pub(event,*args,**kwargs)\n def _pubsend(self,*args,**kwargs):\n  val=getattr(self,self. _TXT)\n  for binding in args:\n   binding(val,self)\n def _pubsendattr(self,attr,*args,**kwargs):\n  val=getattr(self,attr)\n  for binding in args:\n   binding(val,self)\n @property\n def _fmtevt(self):\n  ''  \n  return _FmtEvtHelper(self)\n @property\n def _fmtvalue(self):\n  ''  \n  return _FmtValHelper(self)\n _fmtval=_fmtvalue\n @property\n def _bind(self):\n  ''  \n  return _BindHelper(self)\n @property\n def _bindx(self):\n  ''  \n  return _BindXHelper(self)\n @property\n def _attr(self):\n  ''  \n  return _AttributeHelper(self)\n @property\n def _style(self):\n  ''  \n  return _StyleHelper(self)\n def _display(self,trigger,show='',hide='none'):\n  ''  \n  def st(val):\n   setattr(self. style,'display',show if val else hide)\n  return self. _sub(st,trigger)\n def _display_toggle(self,onoff=None ):\n  ''  \n  curdisplay=self. style. display\n  if onoff is None :\n   if curdisplay is'none':\n    nextdisplay=self. _cvals. get('lastdisplay','')\n    if nextdisplay =='none':\n     nextdisplay=''\n   else :\n    nextdisplay='none'\n   self. style. display=nextdisplay\n  elif isinstance(onoff,str):\n   self. style. display=onoff\n  else :\n   if onoff:\n    if curdisplay =='none':\n     self. style. display=self. _cvals. get('lastdisplay','')\n   else :\n    if curdisplay !='none':\n     self. style. display='none'\n  self. _cvals['lastdisplay']=curdisplay\n  return self\n @property\n def _class(self):\n  ''  \n  return _ClassHelper(self)\nclass _HelperBase:\n helper=None\n def __init__(self,target,helper=None ):\n  if helper is not None :\n   self. helper=helper\n  self. target=target\n def __getattr__(self,name):\n  self. helper=name\n  return self\nclass _BindHelper(_HelperBase):\n def __call__(self,func,*args,**kwargs):\n  evt=self. helper\n  if evt is None :\n   evt=args[0]\n   args=args[1:]\n  return self. target. bind(evt,lambda e:func(e,*args,**kwargs))\nclass _BindXHelper(_HelperBase):\n def __call__(self,func,*args,**kwargs):\n  evt=self. helper\n  if evt is None :\n   evt=args[0]\n   args=args[1:]\n  return self. target. bind(evt,lambda e:func(*args,**kwargs))\nclass _AttributeHelper(_HelperBase):\n def __call__(self,trigger,on=None ,off=None ,*args,**kwargs):\n  helper=self. helper\n  if helper is None :\n   helper=trigger\n   trigger=on\n   on=off\n   off=args[0]\n  if on is None :\n   on='true'\n  if off is None :\n   off=''\n  def st(val,*args,**kwargs):\n   stval=on if val else off\n   setattr(self. target,helper,stval)\n  return self. target. _sub(st,trigger)\nclass _StyleHelper(_HelperBase):\n def __call__(self,trigger,on=None ,off=None ,*args,**kwargs):\n  helper=self. helper\n  if helper is None :\n   helper=trigger\n   trigger=on\n   on=off\n   off=args[0]\n  if on is None :\n   on='true'\n  if off is None :\n   off=''\n  def st(val,*args,**kwargs):\n   stval=on if val else off\n   try :\n    setattr(self. target. style,helper,stval)\n   except Exception as e:\n    pass\n  return self. target. _sub(st,trigger)\nclass _DisplayHelper(_HelperBase):\n helper='display'\n def __call__(self,trigger,show='',hide='none'):\n  def st(val,*args,**kwargs):\n   stval=show if val else hide\n   setattr(self. target. style,self. helper,stval)\n  return self. target. _sub(st,trigger)\nclass _ClassHelper(_HelperBase):\n helper=[]\n def __getattr__(self,name):\n  self. helper. append(name)\n  return self\n def __call__(self,trigger,*args,**kwargs):\n  if not self. helper:\n   self. helper. append(trigger)\n   trigger=args[0]\n  return self. target. _sub(self. _toggle_action,trigger)\n def _toggle_action(self,val):\n  cname=self. target. class_name\n  cs=cname. split(' ')if cname else []\n  for c in self. helper:\n   if val:\n    if c not in cs:\n     cs. append(c)\n   else :\n    try :\n     cs. remove(c)\n    except ValueError:\n     pass\n  self. target. class_name=' '. join(cs)if cs else''\nclass _EvtHelper:\n evt=None\n def __init__(self,target,evt=None ):\n  self. target=target\n  if evt is not None :\n   self. evt=evt\n def __getattr__(self,evt):\n  self. evt=evt\n  return self\n def __call__(self,func,*args,**kwargs):\n  return self. target. bind(self. evt,lambda evt:func(*args,**kwargs))\n def bindx(self,func,*args,**kwargs):\n  return self. target. bind(self. evt,lambda evt:func(*args,**kwargs))\n def bind(self,func,*args,**kwargs):\n  return self. target. bind(self. evt,lambda e:func(e,*args,**kwargs))\nclass _FmtEvtHelper(_EvtHelper):\n def __call__(self,*args,**kwargs):\n  self. target. _fmt(*args,**kwargs)\n  return self. target. _pub(self. evt,*args,**kwargs)\nclass _FmtValHelper(_FmtEvtHelper):\n evt='input'\n def __call__(self,*args,**kwargs):\n  self. target. _fmt(*args,**kwargs)\n  return self. target. _pub(self. evt,*args,**kwargs)\nclass _RenderHelper:\n def __init__(self,target):\n  self. target=target\n  self. _lazy=True\n def __call__(self,func,*args,**kwargs):\n  self. func=func\n  if not self. _lazy:\n   return self. target. _sub(self. _action,*args,**kwargs)\n  return self. target. _subdelay(self. _action,*args,**kwargs)\n def _action(self,*args,**kwargs):\n  self. target. clear()\n  self. func(*args,**kwargs)\n def __getattr__(self,name):\n  if name =='lazy':\n   self. _lazy=True\n   return self\n  return super(). __getattr__(name)\ndef _tout(name,*args,**kwargs):\n try :\n  factory=_thismod. tags[name]\n except KeyError:\n  factory=_customize_tag(name,True )\n return factory(*args,**kwargs)\ndef _tagout(name,*args,**kwargs):\n tout=_tout(name. lower(),*args,**kwargs)\n if tout. _autocomp is not None :\n  tout. _comp. _load()\n  pass\n return tout\ndef _routeout(name,*args,**kwargs):\n return _tout(name. lower(),*args,**kwargs)\ndef _customize_tag(name,dotag=False ,component=None ):\n lname=name. lower()\n dct=_tagmaps[None ]. copy()\n dct. update(_tagmaps. get(lname,{}))\n if dotag:\n  thetag=browser. html. maketag(name)\n else :\n  thetag=getattr(browser. html,name)\n dct['_autocomp']=component\n try :\n  kls=type(lname,(SuperchargedNode,thetag,),dct)\n except TypeError:\n  return None\n for lx in [lname,lname. upper(),lname. capitalize()]:\n  setattr(_thismod,lx,kls)\n  _thismod. tags[lx]=kls\n return kls\n_thismod=getattr(__BRYTHON__. imported,__name__)\ntags={}\n_tag=_tagout\n_KEY=utils. count(1)\n_ELID=utils. count(1)\ndocument=browser. document\n_el2render=[]\n_tagmaps={\nNone :{\n'_TXT':'text',\n'_EVT':'input',\n},\n'input':{\n'_TXT':'value',\n},\n'textarea':{\n'_TXT':'value',\n},\n}\nfor tag in browser. html. tags:\n if tag !='BODY':\n  _customize_tag(tag)\nfor x in ['txt','router-outlet']:\n _customize_tag(x,dotag=True )\n__BRYTHON__. DOMNodeDict. tagsorig=__BRYTHON__. DOMNodeDict. tags\n__BRYTHON__. DOMNodeDict. tags=tags\n"], "anpylar.future": [".py", "\nfrom . timer import call_soon\n__all__=['Future']\nclass InvalidStateError(Exception):\n pass\nclass CancelledError(Exception):\n pass\nclass TimeoutError(Exception):\n pass\nclass CatchError(Exception):\n pass\nclass Future:\n '' \n STATUS_STARTED=0\n STATUS_CANCELED=1\n STATUS_FINISHED=2\n STATUS_ERROR=3\n def __init__(self):\n  self. _status=Future. STATUS_STARTED\n  self. _result=None\n  self. _exception=None\n  self. _callbacks=[]\n def _schedule_callbacks(self):\n  cbs=self. _callbacks[:]\n  self. _callbacks=[]\n  for cb in cbs:\n   call_soon(cb,self)\n def cancel(self):\n  ''  \n  if self. _status !=Future. STATUS_STARTED:\n   return False\n  self. _status=Future. STATUS_CANCELED\n  self. _schedule_callbacks()\n  return True\n def cancelled(self):\n  return self. _status ==Future. STATUS_CANCELED\n def done(self):\n  ''  \n  return self. _status !=Future. STATUS_STARTED\n def result(self):\n  ''  \n  if self. _status ==Future. STATUS_STARTED:\n   raise InvalidStateError()\n  if self. _status ==Future. STATUS_CANCELED:\n   raise CancelledError()\n  if self. _status ==Future. STATUS_ERROR:\n   raise CatchError(self. _exception)\n  return self. _result\n def exception(self):\n  ''  \n  if self. _status ==Future. STATUS_STARTED:\n   raise InvalidStateError()\n  if self. _status ==Future. STATUS_CANCELED:\n   raise CancelledError()\n  if self. _status ==Future. STATUS_ERROR:\n   return self. _exception\n def add_done_callback(self,fn):\n  ''  \n  if self. done():\n   call_soon(fn,self)\n  else :\n   self. _callbacks. append(fn)\n def remove_done_callback(self,fn):\n  ''  \n  lcbs=len(self. _callbacks)\n  self. _callbacks=cbs=[cb for cb in self. _callbacks if cb !=fn]\n  return lcbs -len(cbs)\n def set_result(self,result,noexceptions=False ):\n  ''  \n  if self. _status !=Future. STATUS_STARTED:\n   if noexceptions:\n    return\n   raise InvalidStateError()\n  self. _result=result\n  self. _status=Future. STATUS_FINISHED\n  self. _schedule_callbacks()\n def set_exception(self,exception,noexceptions=False ):\n  ''  \n  if self. _status !=Future. STATUS_STARTED:\n   if noexceptions:\n    return\n   raise InvalidStateError()\n  self. _exception=exception\n  self. _status=Future. STATUS_ERROR\n  self. _schedule_callbacks()\n"], "anpylar.binding": [".py", "\nfrom . observable_attribute import ObservableAttribute\nfrom . import stacks\nfrom . utils import defaultdict\n__all__=['MetaDataBindings','DataBindings','Model']\nclass _Binding(object):\n '' \n def __init__(self,name,default):\n  self. _name=name\n  self. default=default\n  self. cache={None :self}\n  self. subs=defaultdict(list)\n def __get__(self,obj,cls=None ):\n  return self. cache. setdefault(obj,self. default)\n def __set__(self,obj,val,who=None ):\n  self. cache[obj]=val\n  for cb,ptd,whom in self. subs[obj]:\n   if not whom or whom is not who:\n    pval=val if ptd is None else getattr(val,ptd)\n    cb(pval,whom)\n def _notify(self,obj,val,who,ptd):\n  for cb,_ptd,whom,in self. subs. get(obj,[]):\n   if _ptd ==ptd and whom is not who:\n    cb(val,whom)\n def subscribe(self,obj,cb,ptd=None ,who=None ):\n  self. subs[obj]. append((cb,ptd,who))\n  ret=self. __get__(obj)\n  if ptd is not None :\n   ret=getattr(ret,ptd)\n  return ret\n_BINDINGS='bindings'\nclass MetaDataBindings(type):\n '' \n def __new__(meta,name,bases,dct,**kwds):\n  nattrs=dict(dct. pop(_BINDINGS,{}))\n  dct. update({name:_Binding(name,val)for name,val in nattrs. items()})\n  battrs={}\n  _=[battrs. update(getattr(x,_BINDINGS,{}))for x in bases]\n  battrs. update(nattrs)\n  dct[_BINDINGS]=battrs\n  return super(). __new__(meta,name,bases,dct,**kwds)\nclass DataBindings(metaclass=MetaDataBindings):\n '' \n def __new__(cls,*args,**kwargs):\n  attrs=getattr(cls,_BINDINGS)\n  defaults={k:kwargs. pop(k,v)for k,v in attrs. items()}\n  self=super(). __new__(cls,*args,**kwargs)\n  for k,v in defaults. items():\n   setattr(self,k,v)\n   setattr(self,'{}_'. format(k),ObservableAttribute(self,k))\n  return self\nModel=DataBindings\n"], "anpylar.observable_operators": [".py", "\nfrom . observable_base import (ObservableOperator,_MetaObservableOperator,\nDisposable,ObservableStopError)\nfrom . utils import defaultdict\n__all__=[]\nclass All_Operator(ObservableOperator):\n '' \n def __init__(self,predicate):\n  self. _fn=predicate\n  self. _result=True\n def on_next(self,val,sid):\n  if self. _result:\n   self. _result=self. _fn(val)\n def on_completed(self,sid):\n  self. _next(self. _result,sid)\n  super(). on_completed(sid)\nclass Catch_Exception_Operator(ObservableOperator):\n '' \n def __init__(self,handler):\n  self. _handler=handler\n  self. _isobs=isinstance(handler,Observable)\n  self. _active=defaultdict(bool)\n def on_error(self,error,sid):\n  if self. _active[sid]:\n   super. on_error(error,sid)\n   return\n  self. _active[sid]=True\n  self. _error_old,self. _error=self. _error,None\n  if self. _isobs:\n   obs=self. _handler\n  else :\n   obs=self. _handler(error)\n   if not isinstance(obs,Observable):\n    obs=Observable. of(obs)\n  obs. _subscribe(self,sid)\nclass Debounce_Operator(ObservableOperator):\n '' \n _timed_op=True\n def __init__(self,ms):\n  self. tout=ms\n  self. timers=defaultdict(int)\n def _bouncer(self,val,sid):\n  self. timers[sid]=None\n  self. _next(val,sid)\n def on_next(self,val,sid):\n  if self. timers[sid]:\n   self. _delay_stop(sid,self. timers[sid])\n  self. timers[sid]=  self. _delay_next(sid,lambda :self. _bouncer(val,sid),self. tout)\nclass DefVal_Operator(ObservableOperator):\n '' \n def __init__(self,defval):\n  self. defval=defval\n def subscribe(self,*args,**kwargs):\n  disp=super(). subscribe(*args,**kwargs)\n  disp. val=self. defval\n  return disp\nclass Delay_Operator(ObservableOperator):\n '' \n _timed_op=True\n def __init__(self,ms):\n  self. tout=ms\n def on_next(self,val,sid):\n  self. _delay_next(sid,lambda :self. _next(val,sid),self. tout)\nclass Distinct_Operator(ObservableOperator):\n '' \n def __init__(self,predicate=None ):\n  self. _fn=predicate\n  self. _lookup=defaultdict(set)\n def _operate(self,val,sid):\n  fn=self. _fn\n  if fn is None :\n   if val in self. _lookup[sid]:\n    raise ObservableStopError()\n  elif any(fn(v,val)for v in self. _lookup[sid]):\n   raise ObservableStopError()\n  self. _lookup[sid]. add(val)\n  return val\nclass Distinct_Until_Changed_Operator(ObservableOperator):\n '' \n def __init__(self,predicate=None ):\n  self. _fn=predicate if predicate is not None else lambda x,y:x ==y\n  self. _last={}\n def _operate(self,val,sid):\n  if sid in self. _last:\n   if self. _fn(val,self. _last[sid]):\n    raise ObservableStopError()\n  self. _last[sid]=val\n  return val\nclass Do_Action_Operator(ObservableOperator):\n '' \n def __init__(self,action):\n  self. _action=action\n def _operate(self,val,sid):\n  self. _action(val)\n  return val\nclass Filter_Operator(ObservableOperator):\n '' \n def __init__(self,predicate):\n  self. _fn=predicate\n def _operate(self,val,sid):\n  if self. _fn(val):\n   return val\n  raise ObservableStopError()\nclass First_Operator(ObservableOperator):\n '' \n def __init__(self,predicate=None ):\n  self. _fn=predicate if predicate is not None else lambda x:True\n def on_next(self,val,sid):\n  if self. _fn(val):\n   self. _next(val,sid)\n   self. on_completed(sid)\nclass First_Or_Default_Operator(ObservableOperator):\n '' \n def __init__(self,predicate=None ,default_value=None ):\n  self. _delivered=False\n  self. _fn=predicate if predicate is not None else lambda x:True\n  self. _default=default_value\n def on_next(self,val,sid):\n  if self. _fn(val):\n   self. on_completed(sid)\n def on_completed(sid):\n  if not self. _delivered:\n   self. _delivered=True\n   self. _next(self. _default,sid)\n   super(). on_completed(sid)\nclass Map_Operator(ObservableOperator):\n '' \n def __init__(self,fn):\n  self. fn=fn\n def _operate(self,val,sid):\n  return self. fn(val)\nclass Nop_Operator(ObservableOperator):\n '' \n pass\nclass Publish_Operator(ObservableOperator):\n '' \n _cold=-1\n def __init__(self):\n  self. _sid=super(). _get_sid()\n def _get_sid(self):\n  return self. _sid\n def _substrigger(self,sid):\n  if self. _cold <=0:\n   return Disposable(sid=sid)\n  if self. _cold ==1:\n   disp=super(). _substrigger(sid)\n  else :\n   disp=Disposable(sid=sid)\n  self. _cold -=1\n  return disp\n def auto_connect(self,count):\n  self. _cold=max(count,1)\n  return self\n def connect(self):\n  self. _cold=1\n  self. _substrigger(self. _sid)\n  return self\n def on_completed(self,sid):\n  self. _cold=1\n  super(). on_completed(sid)\nclass Switch_Map_Operator(ObservableOperator):\n '' \n def __init__(self,handler):\n  if isinstance(handler,Observable):\n   self. _obsgen=lambda x:handler\n  else :\n   self. _obsgen=lambda x:handler(x)\n  self. _sidmap={}\n  self. _sidobs={}\n  self. _obs=None\n def on_next(self,val,sid):\n  if sid in self. _sidmap:\n   orig_sid=self. _sidmap[sid]\n   if orig_sid is None :\n    self. _sidmap. pop(orig_sid)\n   else :\n    self. _next(val,orig_sid)\n   return\n  if sid in self. _sidobs:\n   obs,obs_sid=self. _sidobs. pop(sid)\n   obs. _unsubscribe(obs_sid)\n   self. _sidmap[obs_sid]=None\n  obs=self. _obsgen(val)\n  if not isinstance(obs,Observable):\n   obs=Observable. of(obs)\n  disp=obs. subscribe(self)\n  obs_sid=disp. sid\n  self. _sidobs[sid]=obs,obs_sid\n  self. _sidmap[obs_sid]=sid\nclass Take_Operator(ObservableOperator):\n '' \n def __init__(self,count):\n  self. to_take=defaultdict(lambda :int(count))\n def on_next(self,val,sid):\n  totake=self. to_take[sid]\n  if totake:\n   self. to_take[sid]=totake -1\n   self. _next(val,sid)\n  if totake <=1:\n   self. to_take[sid]=0\n   self. on_completed(sid)\n   self. _unsubscribe(sid)\nclass Throw__Operator(ObservableOperator):\n '' \n def __init__(self,throw):\n  self. _throw=throw\n def on_next(self,val,sid):\n  self. on_error(self. _throw,sid)\n"], "anpylar.observable_promise": [".py", "\nfrom . observable_base import ObservableOperator,_MetaObservableOperator\nfrom . promise import Promise\n__all__=[]\nclass _MetaToPromise(_MetaObservableOperator):\n def __call__(cls,parent,*args,**kwargs):\n  self=super(). __call__(parent,*args,**kwargs)\n  self. _promise=Promise()\n  self. _parent. _subscribe(self,self. _get_sid())\n  return self. _promise\nclass To_Promise_Operator(ObservableOperator,metaclass=_MetaToPromise):\n def on_next(self,val,sid):\n  self. _promise. _resolve(val)\n def on_error(self,error,sid):\n  self. _promise. _reject(error)\n"], "anpylar.observable_sources": [".py", "\nfrom . observable_base import ObservableSource,_MetaObservableSource\nfrom . utils import defaultdict\n__all__=[]\nclass From__Source(ObservableSource):\n '' \n def __init__(self,iterable):\n  self. _iterable=iterable\n def _subscribed(self,sid,**kwargs):\n  for x in self. _iterable:\n   self. on_next(x,sid=sid)\n  self. on_completed(sid=sid)\nclass Of_Source(ObservableSource):\n '' \n def __init__(self,*args):\n  self. _args=args\n def _subscribed(self,sid,**kwargs):\n  for arg in self. _args:\n   self. on_next(arg,sid=sid)\n  self. on_completed(sid=sid)\nclass Range_Source(ObservableSource):\n '' \n def __init__(self,start,count,step=1):\n  self. _start=start\n  self. _count=count\n  self. _step=step\n def _subscribed(self,sid,**kwargs):\n  for i in range(self. _start,self. _start+self. _count,self. _step):\n   self. on_next(i,sid=sid)\n  self. on_completed(sid=sid)\nclass Throw__Source(ObservableSource):\n '' \n def __init__(self,throw):\n  self. _throw=throw\n def _subscribed(self,sid,**kwargs):\n  self. on_error(self. _throw,sid)\n"], "anpylar.localdata": [".py", "\nimport json\n__all__=['LocalData']\nclass LocalData:\n def __init__(self,data,index,url):\n  self. index=index\n  self. url=url\n  self. idata={d[index]:d for d in data}\n  self. hidx=max(self. idata. keys())\n def __call__(self,method,url,headers,data):\n  dmethod=getattr(self,method. lower())\n  url=url. lstrip(self. url)\n  return dmethod(url,headers,data)\n def get(self,url,headers,data):\n  if data:\n   result=[]\n   search=data\n   for k,v in search. items():\n    v=v. lower()\n    for d in self. idata. values():\n     val=d[k]\n     if v in val. lower():\n      result. append(d)\n   return json. dumps(result)\n  if not url:\n   return json. dumps(list(self. idata. values()))\n  return json. dumps(self. idata. get(int(url),{}))\n def post(self,url,headers,data):\n  d=json. loads(data)\n  self. hidx=idx=self. hidx+1\n  d[self. index]=idx\n  self. idata[idx]=d\n  return json. dumps(d)\n def put(self,url,headers,data):\n  key=int(url)\n  d=json. loads(data)\n  self. idata[key]. update(**d)\n  return json. dumps(d)\n def delete(self,url,headers,data):\n  key=int(url)\n  del self. idata[key]\n  return json. dumps({})\n"], "anpylar.observable_base": [".py", "\nfrom . import config as aconfig\nfrom . timer import call_soon,call_delayed,call_cancel\nfrom . utils import defaultdict\n__all__=['Observer','Observable','_MetaObservable','Disposable',\n'ObservableOperator','_MetaObservableOperator',\n'ObservableSource','_MetaObservableSource',\n'ObservableFetchError','ObservableStopError']\nclass ObservableStopError(Exception):\n pass\nclass ObservableFetchError(Exception):\n def __init__(self,val,*args,**kwargs):\n  super(). __init__(*args,**kwargs)\n  self. val=val\nclass Disposable:\n def __init__(self,**kwargs):\n  self. _parents=[]\n  for k,v in kwargs. items():\n   setattr(self,k,v)\n def _add_parent(self,parent):\n  self. _parents. append(parent)\n def get_val(self):\n  return self. val\n def get_sid(self):\n  return self. sid\n def fetch_val(self):\n  return self. val\nclass Observer:\n def on_next(self,value):\n  pass\n def on_completed(self):\n  pass\n def on_error(self,error):\n  pass\nclass Subscription:\n _timed_op=False\n _error=None\n def __init__(self,parent,on_next=None ,on_completed=None ,on_error=None ):\n  self. _parent=parent\n  self. _on_next=on_next\n  self. _on_completed=on_completed\n  self. _on_error=on_error\n def _suboperate(self,val,sid):\n  return val\n def _operate(self,val,sid):\n  return val\n def on_next(self,val,sid):\n  if not self. _error and self. _on_next:\n   self. _on_next(val)\n def on_completed(self,sid):\n  if not self. _error and self. _on_completed:\n   self. _on_completed()\n def on_error(self,error,sid):\n  self. _error=error\n  if self. _on_error:\n   self. _on_error(error)\n  else :\n   if aconfig. observable. log_error is True :\n    print('on_error:',self,'-',error)\n   elif aconfig. observable. log_error:\n    aconfig. observable. log_error(error)\n   if aconfig. observable. raise_error:\n    raise Exception(error)\nclass _MetaObservable(type):\n def __call__(cls,parent,*args,**kwargs):\n  self=cls. __new__(cls,*args,**kwargs)\n  self. _parent=parent\n  self. _subscriptions=defaultdict(list)\n  self. _in_next=defaultdict(int)\n  self. _to_complete=defaultdict(bool)\n  self. _to_unsubscribe=defaultdict(bool)\n  self. _timers={}\n  self. _next=super(cls,self). on_next\n  self. __init__(*args,**kwargs)\n  return self\n def __getattr__(cls,name):\n  if not name. startswith('__'):\n   try :\n    return cls. _staticmethods[name]\n   except KeyError:\n    pass\n  return super(). __getattr__(name)\nclass Observable(object,metaclass=_MetaObservable):\n _staticmethods={}\n _dynamicmethods={}\n _streamid=1\n _error=None\n _timed_op=False\n def __getattr__(self,name):\n  if not name. startswith('__'):\n   try :\n    cls=Observable. _dynamicmethods[name]\n    return lambda *a,**kw:cls(self,*a,**kw)\n   except KeyError:\n    pass\n  return super(). __getattr__(name)\n def _suboperate(self,val,sid):\n  val=self. _operate(val,sid)\n  for s in self. _subscriptions[sid]:\n   val=s. _suboperate(val,sid)\n   break\n  return val\n def _operate(self,val,sid):\n  return val\n def _delay_next(self,sid,fn,tout=0):\n  if self. _to_complete[sid]or self. _to_unsubscribe[sid]:\n   return 0\n  def cb():\n   self. _in_next[sid]-=1\n   fn()\n  self. _in_next[sid]+=1\n  return call_delayed(tout,cb)\n def _delay_stop(self,sid,t):\n  self. _in_next[sid]-=1\n  call_cancel(t)\n @staticmethod\n def _get_sid():\n  Observable. _streamid=sid=Observable. _streamid+1\n  return sid\n def _substrigger(self,sid,**kwargs):\n  if self. _parent is not None :\n   return self. _parent. _subscribe(self,sid,**kwargs)\n  else :\n   try :\n    self. _subscribed(sid,**kwargs)\n   except ObservableFetchError as e:\n    val=self. _suboperate(e. val,sid)\n    return Disposable(val=val,sid=sid)\n   return Disposable(sid=sid)\n def _subscribe(self,sub,sid,**kwargs):\n  self. _subscriptions[sid]. append(sub)\n  disp=self. _substrigger(sid,**kwargs)\n  disp. _add_parent(self)\n  return disp\n def subscribe(self,on_next,on_completed=None ,on_error=None ,\n observer=None ,fetch=False ,**kwargs):\n  if isinstance(on_next,Subscription):\n   sub=on_next\n  elif isinstance(on_next,ObservableSource):\n   sub=Subscription(self,on_next)\n  elif isinstance(on_next,Observable):\n   sub=on_next\n  elif observer is not None :\n   sub=observer\n  else :\n   if not on_completed:\n    on_completed=getattr(on_next,'on_completed',None )\n   if not on_error:\n    on_error=getattr(on_next,'on_error',None )\n   on_next=getattr(on_next,'on_next',on_next)\n   sub=Subscription(self,on_next,on_completed,on_error)\n  return self. _subscribe(sub,sid=self. _get_sid(),fetch=fetch,**kwargs)\n def _unsubscribe(self,sid):\n  if sid is None :\n   for sid in self. _subscriptions:\n    call_soon(lambda sid=sid:self. _unsubscribe(sid))\n   return\n  if self. _in_next[sid]>0 or self. _to_complete[sid]:\n   self. _to_unsubscribe[sid]=True\n   return\n  self. _to_unsubscribe[sid]=False\n  if self. _parent is not None :\n   self. _parent. _unsubscribe(sid)\n  self. _subscriptions. pop(sid,None )\n  self. _unsubscribed(sid)\n def on_next(self,val,sid=None ):\n  if sid is None :\n   for sid in self. _subscriptions:\n    self. _delay_next(sid,lambda s=sid:self. _streams_next(val,s))\n  elif self. _timed_op:\n   self. _streams_next(val,sid)\n  else :\n   self. _delay_next(sid,lambda :self. _streams_next(val,sid))\n def _streams_next(self,val,sid):\n  self. _in_next[sid]+=1\n  for s in self. _subscriptions[sid]:\n   try :\n    s. on_next(val,sid)\n   except Exception as e:\n    s. on_error(e,sid)\n  self. _in_next[sid]-=1\n  if self. _to_complete[sid]:\n   call_soon(lambda :self. _streams_completed(sid))\n  elif self. _to_unsubscribe[sid]:\n   call_soon(lambda :self. _unsubscribe(sid))\n def on_completed(self,sid):\n  if not self. _error:\n   if not self. _timed_op:\n    call_soon(lambda s=sid:self. _streams_completed(s))\n   else :\n    self. _streams_completed(sid)\n def _streams_completed(self,sid):\n  if sid is None :\n   for sid in self. _subscriptions:\n    call_soon(lambda s=sid:self. _streams_completed(s))\n   return\n  if self. _in_next[sid]>0:\n   self. _to_complete[sid]=True\n   return\n  self. _to_complete[sid]=False\n  for s in self. _subscriptions. pop(sid):\n   try :\n    s. on_completed(sid)\n   except Exception as e:\n    s. on_error(e,sid)\n  if self. _to_unsubscribe[sid]:\n   call_soon(lambda :self. _unsubscribe(sid))\n def on_error(self,error,sid):\n  if aconfig. observable. log_error_early:\n   print('on_error:',self,'-',error)\n  self. _error=error\n  if sid is None :\n   for sid in self. _subscriptions:\n    call_soon(lambda s=sid:self. _streams_error(error,s))\n  else :\n   call_soon(lambda :self. _streams_error(error,sid))\n def _streams_error(self,error,sid):\n  for s in self. _subscriptions. pop(sid):\n   try :\n    s. on_error(error,sid)\n   except Exception as e:\n    pass\n def _subscribed(self,sid,**kwargs):\n  pass\n def _unsubscribed(self,sid):\n  pass\n def __bool__(self):\n  return ObsOpSingle(self,lambda x:bool(x))\n def __eq__(self,other):\n  return ObsOp(self,lambda x,y:x ==y,other)\n def __ne__(self,other):\n  return ObsOp(self,lambda x,y:x !=y,other)\n def __gt__(self,other):\n  return ObsOp(self,lambda x,y:x >y,other)\n def __ge__(self,other):\n  return ObsOp(self,lambda x,y:x >=y,other)\n def __lt__(self,other):\n  return ObsOp(self,lambda x,y:x <y,other)\n def __le__(self,other):\n  return ObsOp(self,lambda x,y:x <=y,other)\nclass _MetaObservableOperator(_MetaObservable):\n def __init__(cls,name,bases,dct,**kwds):\n  super(). __init__(name,bases,dct,**kwds)\n  if name. endswith('_Operator'):\n   obsname=name[:-9]. lower()\n   Observable. _dynamicmethods[obsname]=cls\nclass ObservableOperator(Observable,metaclass=_MetaObservableOperator):\n def on_next(self,val,sid):\n  try :\n   val=self. _operate(val,sid)\n  except ObservableStopError:\n   return\n  super(). on_next(val,sid)\nclass ObsOpSingle(ObservableOperator):\n def __init__(self,op):\n  self. _op=op\n  self. _val=None\n  self. _subscribing=False\n def subscribe(self,on_next,on_completed=None ,on_error=None ,\n observer=None ,fetch=False ,**kwargs):\n  self. _subscribing=True\n  disp1=super(). subscribe(on_next,on_completed,on_error,\n  observer,fetch,**kwargs)\n  sid=disp1. sid\n  self. _subscribing=False\n  if fetch:\n   try :\n    v1=disp1. val\n   except AttributeError:\n    pass\n   else :\n    self. _val=disp1. val=v1\n  return disp1\n def _operate(self,val,sid,ix=0):\n  if self. _subscribing:\n   return val\n  self. _val=val\n  return self. _op(val)\nclass ObsOp(ObservableOperator):\n def __init__(self,op,other):\n  self. _op=op\n  self. _other=other\n  self. _vals=defaultdict(lambda :[float('NaN'),float('NaN')])\n  self. _subscribing=False\n def subscribe(self,on_next,on_completed=None ,on_error=None ,\n observer=None ,fetch=False ,**kwargs):\n  self. _subscribing=True\n  disp1=super(). subscribe(on_next,on_completed,on_error,\n  observer,fetch,**kwargs)\n  sid=disp1. sid\n  other=self. _other\n  if isinstance(other,Observable):\n   disp2=other. subscribe(\n   lambda v,s:self. _operate(v,sid,ix=1),\n   fetch=fetch,**kwargs)\n  else :\n   disp2=Disposable(val=other)\n  self. _subscribing=False\n  if fetch:\n   try :\n    v1,v2=disp1. val,disp2. val\n   except AttributeError:\n    pass\n   else :\n    self. _vals[sid]=[v1,v2]\n    disp1. val=self. _op(v1,v2)\n  return disp1\n def _operate(self,val,sid,ix=0):\n  if self. _subscribing:\n   return val\n  vals=self. _vals[sid]\n  vals[ix]=val\n  return self. _op(*vals)\nclass _MetaObservableSource(_MetaObservable):\n def __init__(cls,name,bases,dct,**kwds):\n  super(). __init__(name,bases,dct,**kwds)\n  if name. endswith('_Source'):\n   obsname=name[:-7]. lower()\n   Observable. _staticmethods[obsname]=(\n   lambda *a,**kw:cls(*a,**kw)\n   )\n def __call__(cls,*args,**kwargs):\n  return super(). __call__(None ,*args,**kwargs)\nclass ObservableSource(Observable,metaclass=_MetaObservableSource):\n pass\n"], "anpylar.observable_attribute": [".py", "\nfrom . utils import operators\nfrom . observable import Observable,ObservableSource,ObservableFetchError\n__all__=['Observable','ObservableAttribute','ObservablePointed']\nclass ObservableAttribute(ObservableSource):\n def __init__(self,obj,name,ptd=None ):\n  self. _desc=getattr(obj. __class__,name)\n  self. _obj=obj\n  self. _name=name\n  self. _ptd=ptd\n  self. _whos={}\n def _subscribed(self,sid,**kwargs):\n  who=getattr(kwargs. get('who',None ),'_elid',None )\n  if who is not None :\n   self. _whos[who]=sid\n  val=self. _desc. subscribe(self. _obj,self. on_next,\n  ptd=self. _ptd,who=sid)\n  self. on_next(val,sid)\n  if kwargs. get('fetch',False ):\n   raise ObservableFetchError(val)\n def on_next(self,val,sid):\n  super(). on_next(val,sid)\n def __getattr__(self,name):\n  if not name. startswith('__'):\n   if name[-1]=='_':\n    op=ObservablePointed(self. _obj,self. _name,name[:-1])\n    setattr(self,name,op)\n    return op\n  return super(). __getattr__(name)\n def __call__(self,val,who=None ):\n  sid=self. _whos. get(getattr(who,'_elid',None ),None )\n  self. _desc. __set__(self. _obj,val,who=sid)\n  return val\nclass ObservablePointed(ObservableAttribute):\n def __call__(self,val,who=None ):\n  sid=self. _whos. get(getattr(who,'_elid',None ),None )\n  ptrobj=self. _desc. __get__(self. _obj)\n  ptrdesc=getattr(ptrobj. __class__,self. _ptd)\n  ptrdesc. __set__(ptrobj,val,who=sid)\n  self. _desc. _notify(self. _obj,val,sid,self. _ptd)\n  return val\n"], "anpylar.config": [".py", "\nclass observable:\n log_error=True\n raise_error=False\n log_error_early=False\nclass router:\n log_comprender=True\nclass module:\n loading_overlay_id='anpylar-loading-overlay'\n"], "anpylar.modbase": [".py", "\nfrom browser import document,window\nimport browser. ajax\nfrom . import html\nfrom . import binding\nclass _MetaMod(binding. MetaDataBindings):\n def __new__(meta,name,bases,dct,**kwds):\n  srv={}\n  for b in bases:\n   srv. update(getattr(b,'services',{}))\n  srv. update(dict(dct. pop('services',{})))\n  dct['services']=srv\n  return super(). __new__(meta,name,bases,dct,**kwds)\n def __init__(cls,name,bases,dct,**kwds):\n  super(). __init__(name,bases,dct,**kwds)\n  urlname=[]\n  lastlower=False\n  for x in name:\n   if x. isupper():\n    if lastlower:\n     urlname. append('_')\n    urlname. append(x. lower())\n    lastlower=False\n   else :\n    urlname. append(x)\n    lastlower=x. islower()\n  cls. _urlname=''. join(urlname)\n def __call__(cls,*args,**kwargs):\n  return super(). __call__(*args,**kwargs)\nclass _ModBase(binding. DataBindings,metaclass=_MetaMod):\n _anpylar_vfs_finder='''\n    ;(function($B){\n        var _b_ = $B.builtins\n        $B._anpyl_vfs_finder = function(path, fullname) {\n            vpf = $B.path_importer_cache[path] // no path check\n            // console.log('vpf is:', vpf)\n            vfs = vpf.vfs[fullname]\n            // console.log('vfs is:', vfs)\n            if(vfs !== undefined)\n                return vfs[1]\n            return _b_.None\n        }\n    })(__BRYTHON__)\n    '''\n __BRYTHON__. win. eval(_anpylar_vfs_finder)\n @staticmethod\n def _get_paketized_file(name):\n  parts=name. split('/')\n  bundle_name='{}.vfs.js/'. format(parts[0])\n  for k in __BRYTHON__. path_importer_cache. to_dict():\n   if not k. endswith(bundle_name):\n    continue\n   return __BRYTHON__. _anpyl_vfs_finder(k,name)\n  return None\n def _css_transform(self,css):\n  cid_name=self. _get_cid_name()\n  if not cid_name:\n   return css\n  prefix='['+cid_name+']'\n  transformed=[]\n  for l in css. splitlines():\n   ls=l. lstrip()\n   if not ls or ls[0]=='@':\n    transformed. append(l)\n    continue\n   bracepos=l. find('{')\n   if bracepos ==-1:\n    transformed. append(l)\n    continue\n   lrest=ls[bracepos:]\n   l=ls[:bracepos]\n   ltokens=l. rstrip(). split()\n   for i,token in enumerate(ltokens):\n    if token =='>':\n     continue\n    if':'in token:\n     ldots=token. split(':')\n     ltokens[i]=ldots[0]+prefix+':'+ldots[-1]\n     continue\n    if token[-1]==',':\n     ltokens[i]=token[:-1]+prefix+','\n     continue\n    ltokens[i]=token+prefix\n   if not (ltokens):\n    ltokens. append(prefix)\n   ltokens. append(lrest)\n   transformed. append(' '. join(ltokens))\n  return'\\n'. join(transformed)\n def _get_urlcomps(self,flag,extension):\n  modname=self. __class__. __module__\n  urlbase='/'. join(modname. split('.')[:-1])\n  urlcomps=[urlbase]*bool(urlbase)\n  if flag is True :\n   urlcomps. append(self. _urlname+extension)\n  else :\n   urlcomps. append(self. stylepath)\n  return'/'. join(urlcomps)\n def _get_cid_name(self):\n  return self. __class__. __name__. lower()+'-'+str(self. _cid)\n @staticmethod\n def _visit_nodes(node):\n  for elem in node. children:\n   Component. _visit_nodes(elem)\n def _insert_style(self,style,cache=True ):\n  if not style:\n   return\n  txt=self. _css_transform(style)\n  with html. render_node(document. head):\n   k={self. _get_cid_name():''}\n   with html. style(**k)as this:\n    this <=txt\n  self. _styled. add(self. __class__)\n  if cache and self. cachesheets:\n   self. _module. cache_add(self. _cachename_style,txt)\n def _stylerer(self,node):\n  if self. __class__ in self. _styled:\n   if self. cachesheets:\n    return\n  if self. cachesheets:\n   cached_style=self. _module. cache_get(self. _cachename_style)\n   if cached_style is not None :\n    return self. _insert_style(cached_style,cache=False )\n  if self. stylesheet:\n   return self. _insert_style(self. stylesheet)\n  if not self. stylepath:\n   return self. _insert_style(self. styler())\n  urlpath=self. _get_urlcomps(self. stylepath,'.css')\n  txt=self. _get_paketized_file(urlpath)\n  if txt is not None :\n   return self. _insert_style(txt)\n  def complete(resp):\n   if resp. status ==200 or resp. status ==0:\n    self. _insert_style(resp. text)\n  url=self. router. _routecalc('',urlpath)\n  a=browser. ajax. ajax()\n  a. bind('complete',complete)\n  url +='?v='+str(window. Date. new(). getTime())\n  a. open('GET',url,True )\n  a. send()\n def styler(self):\n  pass\n"], "anpylar.service": [".py", "\nfrom . import binding\n__all__=['Service']\nclass _MetaService(binding. MetaDataBindings):\n def __call__(cls,parent,module,*args,**kwargs):\n  self=cls. __new__(cls,*args,**kwargs)\n  self. _parent=parent\n  self. _module=module\n  self. __init__(*args,**kwargs)\n  return self\nclass Service(binding. DataBindings,metaclass=_MetaService):\n '' \n def __getattr__(self,name):\n  if name. startswith('__'):\n   return super(). __getattr__(name)\n  return getattr(self. _parent,name)\n"]}

    if(window.__ANPYLAR__ === undefined)
        window.__ANPYLAR__ = {autoload: []}  // ensure global scope

    window.__ANPYLAR__.autoload.push(function($B) {
        // brython removes 1st 2 entries later if stdlib import is true
        // our entry would be removed if placed 1st
        $B.path.splice(2, 0, vfspath)
        $B.imported['_importlib'].VFSAutoPathFinder(vfspath, $vfs)  // autoload
    })
})()
